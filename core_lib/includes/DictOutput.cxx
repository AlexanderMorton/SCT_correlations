//
// File generated by rootcint at Tue Apr 05 23:26:34 2016

// Do NOT change. Changes will be lost next time file is generated
//

#define R__DICTIONARY_FILENAME DictOutput
#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "DictOutput.h"

#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"

// Direct notice to TROOT of the dictionary's loading.
namespace {
   static struct DictInit {
      DictInit() {
         ROOT::RegisterModule();
      }
   } __TheDictionaryInitializer;
}

// START OF SHADOWS

namespace ROOT {
   namespace Shadow {
   } // of namespace Shadow
} // of namespace ROOT
// END OF SHADOWS

namespace ROOT {
   void ProcessorCollection_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ProcessorCollection_Dictionary();
   static void *new_ProcessorCollection(void *p = 0);
   static void *newArray_ProcessorCollection(Long_t size, void *p);
   static void delete_ProcessorCollection(void *p);
   static void deleteArray_ProcessorCollection(void *p);
   static void destruct_ProcessorCollection(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ProcessorCollection*)
   {
      ::ProcessorCollection *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ProcessorCollection),0);
      static ::ROOT::TGenericClassInfo 
         instance("ProcessorCollection", "./sct/ProcessorCollection.h", 12,
                  typeid(::ProcessorCollection), DefineBehavior(ptr, ptr),
                  0, &ProcessorCollection_Dictionary, isa_proxy, 0,
                  sizeof(::ProcessorCollection) );
      instance.SetNew(&new_ProcessorCollection);
      instance.SetNewArray(&newArray_ProcessorCollection);
      instance.SetDelete(&delete_ProcessorCollection);
      instance.SetDeleteArray(&deleteArray_ProcessorCollection);
      instance.SetDestructor(&destruct_ProcessorCollection);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ProcessorCollection*)
   {
      return GenerateInitInstanceLocal((::ProcessorCollection*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ProcessorCollection*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ProcessorCollection_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ProcessorCollection*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void axis_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void axis_Dictionary();
   static void delete_axis(void *p);
   static void deleteArray_axis(void *p);
   static void destruct_axis(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::axis*)
   {
      ::axis *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::axis),0);
      static ::ROOT::TGenericClassInfo 
         instance("axis", "./sct/axis.hh", 10,
                  typeid(::axis), DefineBehavior(ptr, ptr),
                  0, &axis_Dictionary, isa_proxy, 0,
                  sizeof(::axis) );
      instance.SetDelete(&delete_axis);
      instance.SetDeleteArray(&deleteArray_axis);
      instance.SetDestructor(&destruct_axis);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::axis*)
   {
      return GenerateInitInstanceLocal((::axis*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::axis*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void axis_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::axis*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void generic_plane_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void generic_plane_Dictionary();
   static void *new_generic_plane(void *p = 0);
   static void *newArray_generic_plane(Long_t size, void *p);
   static void delete_generic_plane(void *p);
   static void deleteArray_generic_plane(void *p);
   static void destruct_generic_plane(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::generic_plane*)
   {
      ::generic_plane *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::generic_plane),0);
      static ::ROOT::TGenericClassInfo 
         instance("generic_plane", "./sct/generic_plane.hh", 27,
                  typeid(::generic_plane), DefineBehavior(ptr, ptr),
                  0, &generic_plane_Dictionary, isa_proxy, 0,
                  sizeof(::generic_plane) );
      instance.SetNew(&new_generic_plane);
      instance.SetNewArray(&newArray_generic_plane);
      instance.SetDelete(&delete_generic_plane);
      instance.SetDeleteArray(&deleteArray_generic_plane);
      instance.SetDestructor(&destruct_generic_plane);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::generic_plane*)
   {
      return GenerateInitInstanceLocal((::generic_plane*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::generic_plane*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void generic_plane_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::generic_plane*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void processor_prob_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void processor_prob_Dictionary();
   static void *new_processor_prob(void *p = 0);
   static void *newArray_processor_prob(Long_t size, void *p);
   static void delete_processor_prob(void *p);
   static void deleteArray_processor_prob(void *p);
   static void destruct_processor_prob(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::processor_prob*)
   {
      ::processor_prob *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::processor_prob),0);
      static ::ROOT::TGenericClassInfo 
         instance("processor_prob", "./sct/processor_prob.hh", 8,
                  typeid(::processor_prob), DefineBehavior(ptr, ptr),
                  0, &processor_prob_Dictionary, isa_proxy, 0,
                  sizeof(::processor_prob) );
      instance.SetNew(&new_processor_prob);
      instance.SetNewArray(&newArray_processor_prob);
      instance.SetDelete(&delete_processor_prob);
      instance.SetDeleteArray(&deleteArray_processor_prob);
      instance.SetDestructor(&destruct_processor_prob);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::processor_prob*)
   {
      return GenerateInitInstanceLocal((::processor_prob*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::processor_prob*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void processor_prob_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::processor_prob*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void collection_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void collection_Dictionary();
   static void delete_collection(void *p);
   static void deleteArray_collection(void *p);
   static void destruct_collection(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::collection*)
   {
      ::collection *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::collection),0);
      static ::ROOT::TGenericClassInfo 
         instance("collection", "./sct/collection.h", 24,
                  typeid(::collection), DefineBehavior(ptr, ptr),
                  0, &collection_Dictionary, isa_proxy, 0,
                  sizeof(::collection) );
      instance.SetDelete(&delete_collection);
      instance.SetDeleteArray(&deleteArray_collection);
      instance.SetDestructor(&destruct_collection);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::collection*)
   {
      return GenerateInitInstanceLocal((::collection*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::collection*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void collection_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::collection*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void EUTFile_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void EUTFile_Dictionary();
   static void delete_EUTFile(void *p);
   static void deleteArray_EUTFile(void *p);
   static void destruct_EUTFile(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::EUTFile*)
   {
      ::EUTFile *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::EUTFile),0);
      static ::ROOT::TGenericClassInfo 
         instance("EUTFile", "./sct/EUTFile.h", 14,
                  typeid(::EUTFile), DefineBehavior(ptr, ptr),
                  0, &EUTFile_Dictionary, isa_proxy, 0,
                  sizeof(::EUTFile) );
      instance.SetDelete(&delete_EUTFile);
      instance.SetDeleteArray(&deleteArray_EUTFile);
      instance.SetDestructor(&destruct_EUTFile);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::EUTFile*)
   {
      return GenerateInitInstanceLocal((::EUTFile*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::EUTFile*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void EUTFile_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::EUTFile*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void processor_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void processor_Dictionary();
   static void delete_processor(void *p);
   static void deleteArray_processor(void *p);
   static void destruct_processor(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::processor*)
   {
      ::processor *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::processor),0);
      static ::ROOT::TGenericClassInfo 
         instance("processor", "./sct/processor.h", 23,
                  typeid(::processor), DefineBehavior(ptr, ptr),
                  0, &processor_Dictionary, isa_proxy, 0,
                  sizeof(::processor) );
      instance.SetDelete(&delete_processor);
      instance.SetDeleteArray(&deleteArray_processor);
      instance.SetDestructor(&destruct_processor);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::processor*)
   {
      return GenerateInitInstanceLocal((::processor*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::processor*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void processor_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::processor*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void hit_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void hit_Dictionary();
   static void *new_hit(void *p = 0);
   static void *newArray_hit(Long_t size, void *p);
   static void delete_hit(void *p);
   static void deleteArray_hit(void *p);
   static void destruct_hit(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::hit*)
   {
      ::hit *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::hit),0);
      static ::ROOT::TGenericClassInfo 
         instance("hit", "./sct/predef/hit.hh", 4,
                  typeid(::hit), DefineBehavior(ptr, ptr),
                  0, &hit_Dictionary, isa_proxy, 0,
                  sizeof(::hit) );
      instance.SetNew(&new_hit);
      instance.SetNewArray(&newArray_hit);
      instance.SetDelete(&delete_hit);
      instance.SetDeleteArray(&deleteArray_hit);
      instance.SetDestructor(&destruct_hit);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::hit*)
   {
      return GenerateInitInstanceLocal((::hit*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::hit*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void hit_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::hit*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void fitterHit_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void fitterHit_Dictionary();
   static void *new_fitterHit(void *p = 0);
   static void *newArray_fitterHit(Long_t size, void *p);
   static void delete_fitterHit(void *p);
   static void deleteArray_fitterHit(void *p);
   static void destruct_fitterHit(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::fitterHit*)
   {
      ::fitterHit *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::fitterHit),0);
      static ::ROOT::TGenericClassInfo 
         instance("fitterHit", "./sct/predef/hit.hh", 10,
                  typeid(::fitterHit), DefineBehavior(ptr, ptr),
                  0, &fitterHit_Dictionary, isa_proxy, 0,
                  sizeof(::fitterHit) );
      instance.SetNew(&new_fitterHit);
      instance.SetNewArray(&newArray_fitterHit);
      instance.SetDelete(&delete_fitterHit);
      instance.SetDeleteArray(&deleteArray_fitterHit);
      instance.SetDestructor(&destruct_fitterHit);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::fitterHit*)
   {
      return GenerateInitInstanceLocal((::fitterHit*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::fitterHit*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void fitterHit_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::fitterHit*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void plane_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void plane_Dictionary();
   static void delete_plane(void *p);
   static void deleteArray_plane(void *p);
   static void destruct_plane(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::plane*)
   {
      ::plane *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::plane),0);
      static ::ROOT::TGenericClassInfo 
         instance("plane", "./sct/predef/plane.hh", 15,
                  typeid(::plane), DefineBehavior(ptr, ptr),
                  0, &plane_Dictionary, isa_proxy, 0,
                  sizeof(::plane) );
      instance.SetDelete(&delete_plane);
      instance.SetDeleteArray(&deleteArray_plane);
      instance.SetDestructor(&destruct_plane);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::plane*)
   {
      return GenerateInitInstanceLocal((::plane*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::plane*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void plane_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::plane*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void xy_plane_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void xy_plane_Dictionary();
   static void *new_xy_plane(void *p = 0);
   static void *newArray_xy_plane(Long_t size, void *p);
   static void delete_xy_plane(void *p);
   static void deleteArray_xy_plane(void *p);
   static void destruct_xy_plane(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::xy_plane*)
   {
      ::xy_plane *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::xy_plane),0);
      static ::ROOT::TGenericClassInfo 
         instance("xy_plane", "./sct/predef/plane.hh", 28,
                  typeid(::xy_plane), DefineBehavior(ptr, ptr),
                  0, &xy_plane_Dictionary, isa_proxy, 0,
                  sizeof(::xy_plane) );
      instance.SetNew(&new_xy_plane);
      instance.SetNewArray(&newArray_xy_plane);
      instance.SetDelete(&delete_xy_plane);
      instance.SetDeleteArray(&deleteArray_xy_plane);
      instance.SetDestructor(&destruct_xy_plane);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::xy_plane*)
   {
      return GenerateInitInstanceLocal((::xy_plane*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::xy_plane*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void xy_plane_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::xy_plane*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void FitterPlane_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void FitterPlane_Dictionary();
   static void *new_FitterPlane(void *p = 0);
   static void *newArray_FitterPlane(Long_t size, void *p);
   static void delete_FitterPlane(void *p);
   static void deleteArray_FitterPlane(void *p);
   static void destruct_FitterPlane(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::FitterPlane*)
   {
      ::FitterPlane *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::FitterPlane),0);
      static ::ROOT::TGenericClassInfo 
         instance("FitterPlane", "./sct/predef/plane.hh", 42,
                  typeid(::FitterPlane), DefineBehavior(ptr, ptr),
                  0, &FitterPlane_Dictionary, isa_proxy, 0,
                  sizeof(::FitterPlane) );
      instance.SetNew(&new_FitterPlane);
      instance.SetNewArray(&newArray_FitterPlane);
      instance.SetDelete(&delete_FitterPlane);
      instance.SetDeleteArray(&deleteArray_FitterPlane);
      instance.SetDestructor(&destruct_FitterPlane);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::FitterPlane*)
   {
      return GenerateInitInstanceLocal((::FitterPlane*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::FitterPlane*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void FitterPlane_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::FitterPlane*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void processorPlaneVSPlane_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void processorPlaneVSPlane_Dictionary();
   static void delete_processorPlaneVSPlane(void *p);
   static void deleteArray_processorPlaneVSPlane(void *p);
   static void destruct_processorPlaneVSPlane(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::processorPlaneVSPlane*)
   {
      ::processorPlaneVSPlane *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::processorPlaneVSPlane),0);
      static ::ROOT::TGenericClassInfo 
         instance("processorPlaneVSPlane", "./sct/xy_processors/processorPlaneVSPlane.h", 11,
                  typeid(::processorPlaneVSPlane), DefineBehavior(ptr, ptr),
                  0, &processorPlaneVSPlane_Dictionary, isa_proxy, 0,
                  sizeof(::processorPlaneVSPlane) );
      instance.SetDelete(&delete_processorPlaneVSPlane);
      instance.SetDeleteArray(&deleteArray_processorPlaneVSPlane);
      instance.SetDestructor(&destruct_processorPlaneVSPlane);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::processorPlaneVSPlane*)
   {
      return GenerateInitInstanceLocal((::processorPlaneVSPlane*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::processorPlaneVSPlane*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void processorPlaneVSPlane_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::processorPlaneVSPlane*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void Xladder_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void Xladder_Dictionary();
   static void *new_Xladder(void *p = 0);
   static void *newArray_Xladder(Long_t size, void *p);
   static void delete_Xladder(void *p);
   static void deleteArray_Xladder(void *p);
   static void destruct_Xladder(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Xladder*)
   {
      ::Xladder *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Xladder),0);
      static ::ROOT::TGenericClassInfo 
         instance("Xladder", "./sct/lagacy/setup_description.hh", 10,
                  typeid(::Xladder), DefineBehavior(ptr, ptr),
                  0, &Xladder_Dictionary, isa_proxy, 0,
                  sizeof(::Xladder) );
      instance.SetNew(&new_Xladder);
      instance.SetNewArray(&newArray_Xladder);
      instance.SetDelete(&delete_Xladder);
      instance.SetDeleteArray(&deleteArray_Xladder);
      instance.SetDestructor(&destruct_Xladder);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Xladder*)
   {
      return GenerateInitInstanceLocal((::Xladder*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Xladder*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void Xladder_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Xladder*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void Xsensitive_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void Xsensitive_Dictionary();
   static void *new_Xsensitive(void *p = 0);
   static void *newArray_Xsensitive(Long_t size, void *p);
   static void delete_Xsensitive(void *p);
   static void deleteArray_Xsensitive(void *p);
   static void destruct_Xsensitive(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Xsensitive*)
   {
      ::Xsensitive *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Xsensitive),0);
      static ::ROOT::TGenericClassInfo 
         instance("Xsensitive", "./sct/lagacy/setup_description.hh", 28,
                  typeid(::Xsensitive), DefineBehavior(ptr, ptr),
                  0, &Xsensitive_Dictionary, isa_proxy, 0,
                  sizeof(::Xsensitive) );
      instance.SetNew(&new_Xsensitive);
      instance.SetNewArray(&newArray_Xsensitive);
      instance.SetDelete(&delete_Xsensitive);
      instance.SetDeleteArray(&deleteArray_Xsensitive);
      instance.SetDestructor(&destruct_Xsensitive);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Xsensitive*)
   {
      return GenerateInitInstanceLocal((::Xsensitive*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Xsensitive*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void Xsensitive_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Xsensitive*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void Xlayer_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void Xlayer_Dictionary();
   static void delete_Xlayer(void *p);
   static void deleteArray_Xlayer(void *p);
   static void destruct_Xlayer(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Xlayer*)
   {
      ::Xlayer *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Xlayer),0);
      static ::ROOT::TGenericClassInfo 
         instance("Xlayer", "./sct/lagacy/setup_description.hh", 51,
                  typeid(::Xlayer), DefineBehavior(ptr, ptr),
                  0, &Xlayer_Dictionary, isa_proxy, 0,
                  sizeof(::Xlayer) );
      instance.SetDelete(&delete_Xlayer);
      instance.SetDeleteArray(&deleteArray_Xlayer);
      instance.SetDestructor(&destruct_Xlayer);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Xlayer*)
   {
      return GenerateInitInstanceLocal((::Xlayer*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Xlayer*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void Xlayer_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Xlayer*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void Xdetector_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void Xdetector_Dictionary();
   static void *new_Xdetector(void *p = 0);
   static void *newArray_Xdetector(Long_t size, void *p);
   static void delete_Xdetector(void *p);
   static void deleteArray_Xdetector(void *p);
   static void destruct_Xdetector(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Xdetector*)
   {
      ::Xdetector *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Xdetector),0);
      static ::ROOT::TGenericClassInfo 
         instance("Xdetector", "./sct/lagacy/setup_description.hh", 58,
                  typeid(::Xdetector), DefineBehavior(ptr, ptr),
                  0, &Xdetector_Dictionary, isa_proxy, 0,
                  sizeof(::Xdetector) );
      instance.SetNew(&new_Xdetector);
      instance.SetNewArray(&newArray_Xdetector);
      instance.SetDelete(&delete_Xdetector);
      instance.SetDeleteArray(&deleteArray_Xdetector);
      instance.SetDestructor(&destruct_Xdetector);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Xdetector*)
   {
      return GenerateInitInstanceLocal((::Xdetector*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Xdetector*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void Xdetector_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Xdetector*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void XBField_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void XBField_Dictionary();
   static void *new_XBField(void *p = 0);
   static void *newArray_XBField(Long_t size, void *p);
   static void delete_XBField(void *p);
   static void deleteArray_XBField(void *p);
   static void destruct_XBField(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::XBField*)
   {
      ::XBField *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::XBField),0);
      static ::ROOT::TGenericClassInfo 
         instance("XBField", "./sct/lagacy/setup_description.hh", 70,
                  typeid(::XBField), DefineBehavior(ptr, ptr),
                  0, &XBField_Dictionary, isa_proxy, 0,
                  sizeof(::XBField) );
      instance.SetNew(&new_XBField);
      instance.SetNewArray(&newArray_XBField);
      instance.SetDelete(&delete_XBField);
      instance.SetDeleteArray(&deleteArray_XBField);
      instance.SetDestructor(&destruct_XBField);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::XBField*)
   {
      return GenerateInitInstanceLocal((::XBField*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::XBField*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void XBField_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::XBField*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void Xgear_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void Xgear_Dictionary();
   static void *new_Xgear(void *p = 0);
   static void *newArray_Xgear(Long_t size, void *p);
   static void delete_Xgear(void *p);
   static void deleteArray_Xgear(void *p);
   static void destruct_Xgear(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::Xgear*)
   {
      ::Xgear *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::Xgear),0);
      static ::ROOT::TGenericClassInfo 
         instance("Xgear", "./sct/lagacy/setup_description.hh", 78,
                  typeid(::Xgear), DefineBehavior(ptr, ptr),
                  0, &Xgear_Dictionary, isa_proxy, 0,
                  sizeof(::Xgear) );
      instance.SetNew(&new_Xgear);
      instance.SetNewArray(&newArray_Xgear);
      instance.SetDelete(&delete_Xgear);
      instance.SetDeleteArray(&deleteArray_Xgear);
      instance.SetDestructor(&destruct_Xgear);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::Xgear*)
   {
      return GenerateInitInstanceLocal((::Xgear*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::Xgear*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void Xgear_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::Xgear*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void S_Cut_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void S_Cut_Dictionary();
   static void *new_S_Cut(void *p = 0);
   static void *newArray_S_Cut(Long_t size, void *p);
   static void delete_S_Cut(void *p);
   static void deleteArray_S_Cut(void *p);
   static void destruct_S_Cut(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::S_Cut*)
   {
      ::S_Cut *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::S_Cut),0);
      static ::ROOT::TGenericClassInfo 
         instance("S_Cut", "./sct/lagacy/s_cuts.h", 11,
                  typeid(::S_Cut), DefineBehavior(ptr, ptr),
                  0, &S_Cut_Dictionary, isa_proxy, 0,
                  sizeof(::S_Cut) );
      instance.SetNew(&new_S_Cut);
      instance.SetNewArray(&newArray_S_Cut);
      instance.SetDelete(&delete_S_Cut);
      instance.SetDeleteArray(&deleteArray_S_Cut);
      instance.SetDestructor(&destruct_S_Cut);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::S_Cut*)
   {
      return GenerateInitInstanceLocal((::S_Cut*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::S_Cut*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void S_Cut_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::S_Cut*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void S_NoCut_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void S_NoCut_Dictionary();
   static void *new_S_NoCut(void *p = 0);
   static void *newArray_S_NoCut(Long_t size, void *p);
   static void delete_S_NoCut(void *p);
   static void deleteArray_S_NoCut(void *p);
   static void destruct_S_NoCut(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::S_NoCut*)
   {
      ::S_NoCut *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::S_NoCut),0);
      static ::ROOT::TGenericClassInfo 
         instance("S_NoCut", "./sct/lagacy/s_cuts.h", 28,
                  typeid(::S_NoCut), DefineBehavior(ptr, ptr),
                  0, &S_NoCut_Dictionary, isa_proxy, 0,
                  sizeof(::S_NoCut) );
      instance.SetNew(&new_S_NoCut);
      instance.SetNewArray(&newArray_S_NoCut);
      instance.SetDelete(&delete_S_NoCut);
      instance.SetDeleteArray(&deleteArray_S_NoCut);
      instance.SetDestructor(&destruct_S_NoCut);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::S_NoCut*)
   {
      return GenerateInitInstanceLocal((::S_NoCut*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::S_NoCut*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void S_NoCut_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::S_NoCut*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void S_XCut_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void S_XCut_Dictionary();
   static void delete_S_XCut(void *p);
   static void deleteArray_S_XCut(void *p);
   static void destruct_S_XCut(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::S_XCut*)
   {
      ::S_XCut *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::S_XCut),0);
      static ::ROOT::TGenericClassInfo 
         instance("S_XCut", "./sct/lagacy/s_cuts.h", 60,
                  typeid(::S_XCut), DefineBehavior(ptr, ptr),
                  0, &S_XCut_Dictionary, isa_proxy, 0,
                  sizeof(::S_XCut) );
      instance.SetDelete(&delete_S_XCut);
      instance.SetDeleteArray(&deleteArray_S_XCut);
      instance.SetDestructor(&destruct_S_XCut);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::S_XCut*)
   {
      return GenerateInitInstanceLocal((::S_XCut*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::S_XCut*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void S_XCut_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::S_XCut*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void S_YCut_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void S_YCut_Dictionary();
   static void delete_S_YCut(void *p);
   static void deleteArray_S_YCut(void *p);
   static void destruct_S_YCut(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::S_YCut*)
   {
      ::S_YCut *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::S_YCut),0);
      static ::ROOT::TGenericClassInfo 
         instance("S_YCut", "./sct/lagacy/s_cuts.h", 76,
                  typeid(::S_YCut), DefineBehavior(ptr, ptr),
                  0, &S_YCut_Dictionary, isa_proxy, 0,
                  sizeof(::S_YCut) );
      instance.SetDelete(&delete_S_YCut);
      instance.SetDeleteArray(&deleteArray_S_YCut);
      instance.SetDestructor(&destruct_S_YCut);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::S_YCut*)
   {
      return GenerateInitInstanceLocal((::S_YCut*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::S_YCut*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void S_YCut_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::S_YCut*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void S_Cut_BinContent_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void S_Cut_BinContent_Dictionary();
   static void delete_S_Cut_BinContent(void *p);
   static void deleteArray_S_Cut_BinContent(void *p);
   static void destruct_S_Cut_BinContent(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::S_Cut_BinContent*)
   {
      ::S_Cut_BinContent *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::S_Cut_BinContent),0);
      static ::ROOT::TGenericClassInfo 
         instance("S_Cut_BinContent", "./sct/lagacy/s_cuts.h", 91,
                  typeid(::S_Cut_BinContent), DefineBehavior(ptr, ptr),
                  0, &S_Cut_BinContent_Dictionary, isa_proxy, 0,
                  sizeof(::S_Cut_BinContent) );
      instance.SetDelete(&delete_S_Cut_BinContent);
      instance.SetDeleteArray(&deleteArray_S_Cut_BinContent);
      instance.SetDestructor(&destruct_S_Cut_BinContent);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::S_Cut_BinContent*)
   {
      return GenerateInitInstanceLocal((::S_Cut_BinContent*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::S_Cut_BinContent*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void S_Cut_BinContent_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::S_Cut_BinContent*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void S_CutCoollection_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void S_CutCoollection_Dictionary();
   static void *new_S_CutCoollection(void *p = 0);
   static void *newArray_S_CutCoollection(Long_t size, void *p);
   static void delete_S_CutCoollection(void *p);
   static void deleteArray_S_CutCoollection(void *p);
   static void destruct_S_CutCoollection(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::S_CutCoollection*)
   {
      ::S_CutCoollection *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::S_CutCoollection),0);
      static ::ROOT::TGenericClassInfo 
         instance("S_CutCoollection", "./sct/lagacy/s_cuts.h", 108,
                  typeid(::S_CutCoollection), DefineBehavior(ptr, ptr),
                  0, &S_CutCoollection_Dictionary, isa_proxy, 0,
                  sizeof(::S_CutCoollection) );
      instance.SetNew(&new_S_CutCoollection);
      instance.SetNewArray(&newArray_S_CutCoollection);
      instance.SetDelete(&delete_S_CutCoollection);
      instance.SetDeleteArray(&deleteArray_S_CutCoollection);
      instance.SetDestructor(&destruct_S_CutCoollection);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::S_CutCoollection*)
   {
      return GenerateInitInstanceLocal((::S_CutCoollection*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::S_CutCoollection*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void S_CutCoollection_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::S_CutCoollection*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void MinMaxRange_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void MinMaxRange_Dictionary();
   static void *new_MinMaxRange(void *p = 0);
   static void *newArray_MinMaxRange(Long_t size, void *p);
   static void delete_MinMaxRange(void *p);
   static void deleteArray_MinMaxRange(void *p);
   static void destruct_MinMaxRange(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::MinMaxRange*)
   {
      ::MinMaxRange *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::MinMaxRange),0);
      static ::ROOT::TGenericClassInfo 
         instance("MinMaxRange", "./sct/lagacy/xml_input_file.hh", 17,
                  typeid(::MinMaxRange), DefineBehavior(ptr, ptr),
                  0, &MinMaxRange_Dictionary, isa_proxy, 0,
                  sizeof(::MinMaxRange) );
      instance.SetNew(&new_MinMaxRange);
      instance.SetNewArray(&newArray_MinMaxRange);
      instance.SetDelete(&delete_MinMaxRange);
      instance.SetDeleteArray(&deleteArray_MinMaxRange);
      instance.SetDestructor(&destruct_MinMaxRange);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::MinMaxRange*)
   {
      return GenerateInitInstanceLocal((::MinMaxRange*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::MinMaxRange*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void MinMaxRange_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::MinMaxRange*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void xml_globalConfig_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void xml_globalConfig_Dictionary();
   static void *new_xml_globalConfig(void *p = 0);
   static void *newArray_xml_globalConfig(Long_t size, void *p);
   static void delete_xml_globalConfig(void *p);
   static void deleteArray_xml_globalConfig(void *p);
   static void destruct_xml_globalConfig(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::xml_globalConfig*)
   {
      ::xml_globalConfig *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::xml_globalConfig),0);
      static ::ROOT::TGenericClassInfo 
         instance("xml_globalConfig", "./sct/lagacy/xml_input_file.hh", 30,
                  typeid(::xml_globalConfig), DefineBehavior(ptr, ptr),
                  0, &xml_globalConfig_Dictionary, isa_proxy, 0,
                  sizeof(::xml_globalConfig) );
      instance.SetNew(&new_xml_globalConfig);
      instance.SetNewArray(&newArray_xml_globalConfig);
      instance.SetDelete(&delete_xml_globalConfig);
      instance.SetDeleteArray(&deleteArray_xml_globalConfig);
      instance.SetDestructor(&destruct_xml_globalConfig);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::xml_globalConfig*)
   {
      return GenerateInitInstanceLocal((::xml_globalConfig*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::xml_globalConfig*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void xml_globalConfig_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::xml_globalConfig*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void xml_file_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void xml_file_Dictionary();
   static void *new_xml_file(void *p = 0);
   static void *newArray_xml_file(Long_t size, void *p);
   static void delete_xml_file(void *p);
   static void deleteArray_xml_file(void *p);
   static void destruct_xml_file(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::xml_file*)
   {
      ::xml_file *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::xml_file),0);
      static ::ROOT::TGenericClassInfo 
         instance("xml_file", "./sct/lagacy/xml_input_file.hh", 55,
                  typeid(::xml_file), DefineBehavior(ptr, ptr),
                  0, &xml_file_Dictionary, isa_proxy, 0,
                  sizeof(::xml_file) );
      instance.SetNew(&new_xml_file);
      instance.SetNewArray(&newArray_xml_file);
      instance.SetDelete(&delete_xml_file);
      instance.SetDeleteArray(&deleteArray_xml_file);
      instance.SetDestructor(&destruct_xml_file);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::xml_file*)
   {
      return GenerateInitInstanceLocal((::xml_file*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::xml_file*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void xml_file_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::xml_file*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void XML_imput_file_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void XML_imput_file_Dictionary();
   static void delete_XML_imput_file(void *p);
   static void deleteArray_XML_imput_file(void *p);
   static void destruct_XML_imput_file(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::XML_imput_file*)
   {
      ::XML_imput_file *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::XML_imput_file),0);
      static ::ROOT::TGenericClassInfo 
         instance("XML_imput_file", "./sct/lagacy/xml_input_file.hh", 70,
                  typeid(::XML_imput_file), DefineBehavior(ptr, ptr),
                  0, &XML_imput_file_Dictionary, isa_proxy, 0,
                  sizeof(::XML_imput_file) );
      instance.SetDelete(&delete_XML_imput_file);
      instance.SetDeleteArray(&deleteArray_XML_imput_file);
      instance.SetDestructor(&destruct_XML_imput_file);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::XML_imput_file*)
   {
      return GenerateInitInstanceLocal((::XML_imput_file*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::XML_imput_file*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void XML_imput_file_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::XML_imput_file*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void DrawOption_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void DrawOption_Dictionary();
   static void *new_DrawOption(void *p = 0);
   static void *newArray_DrawOption(Long_t size, void *p);
   static void delete_DrawOption(void *p);
   static void deleteArray_DrawOption(void *p);
   static void destruct_DrawOption(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::DrawOption*)
   {
      ::DrawOption *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::DrawOption),0);
      static ::ROOT::TGenericClassInfo 
         instance("DrawOption", "./sct/lagacy/Draw.h", 13,
                  typeid(::DrawOption), DefineBehavior(ptr, ptr),
                  0, &DrawOption_Dictionary, isa_proxy, 0,
                  sizeof(::DrawOption) );
      instance.SetNew(&new_DrawOption);
      instance.SetNewArray(&newArray_DrawOption);
      instance.SetDelete(&delete_DrawOption);
      instance.SetDeleteArray(&deleteArray_DrawOption);
      instance.SetDestructor(&destruct_DrawOption);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::DrawOption*)
   {
      return GenerateInitInstanceLocal((::DrawOption*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::DrawOption*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void DrawOption_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::DrawOption*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_hit(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::hit : new ::hit;
   }
   static void *newArray_hit(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::hit[nElements] : new ::hit[nElements];
   }
   // Wrapper around operator delete
   static void delete_hit(void *p) {
      delete ((::hit*)p);
   }
   static void deleteArray_hit(void *p) {
      delete [] ((::hit*)p);
   }
   static void destruct_hit(void *p) {
      typedef ::hit current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::hit

namespace ROOT {
   // Wrappers around operator new
   static void *new_fitterHit(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::fitterHit : new ::fitterHit;
   }
   static void *newArray_fitterHit(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::fitterHit[nElements] : new ::fitterHit[nElements];
   }
   // Wrapper around operator delete
   static void delete_fitterHit(void *p) {
      delete ((::fitterHit*)p);
   }
   static void deleteArray_fitterHit(void *p) {
      delete [] ((::fitterHit*)p);
   }
   static void destruct_fitterHit(void *p) {
      typedef ::fitterHit current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::fitterHit

namespace ROOT {
   // Wrapper around operator delete
   static void delete_plane(void *p) {
      delete ((::plane*)p);
   }
   static void deleteArray_plane(void *p) {
      delete [] ((::plane*)p);
   }
   static void destruct_plane(void *p) {
      typedef ::plane current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::plane

namespace ROOT {
   // Wrappers around operator new
   static void *new_xy_plane(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::xy_plane : new ::xy_plane;
   }
   static void *newArray_xy_plane(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::xy_plane[nElements] : new ::xy_plane[nElements];
   }
   // Wrapper around operator delete
   static void delete_xy_plane(void *p) {
      delete ((::xy_plane*)p);
   }
   static void deleteArray_xy_plane(void *p) {
      delete [] ((::xy_plane*)p);
   }
   static void destruct_xy_plane(void *p) {
      typedef ::xy_plane current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::xy_plane

namespace ROOT {
   // Wrappers around operator new
   static void *new_FitterPlane(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::FitterPlane : new ::FitterPlane;
   }
   static void *newArray_FitterPlane(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::FitterPlane[nElements] : new ::FitterPlane[nElements];
   }
   // Wrapper around operator delete
   static void delete_FitterPlane(void *p) {
      delete ((::FitterPlane*)p);
   }
   static void deleteArray_FitterPlane(void *p) {
      delete [] ((::FitterPlane*)p);
   }
   static void destruct_FitterPlane(void *p) {
      typedef ::FitterPlane current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::FitterPlane

namespace ROOT {
   // Wrapper around operator delete
   static void delete_axis(void *p) {
      delete ((::axis*)p);
   }
   static void deleteArray_axis(void *p) {
      delete [] ((::axis*)p);
   }
   static void destruct_axis(void *p) {
      typedef ::axis current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::axis

namespace ROOT {
   // Wrapper around operator delete
   static void delete_collection(void *p) {
      delete ((::collection*)p);
   }
   static void deleteArray_collection(void *p) {
      delete [] ((::collection*)p);
   }
   static void destruct_collection(void *p) {
      typedef ::collection current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::collection

namespace ROOT {
   // Wrapper around operator delete
   static void delete_EUTFile(void *p) {
      delete ((::EUTFile*)p);
   }
   static void deleteArray_EUTFile(void *p) {
      delete [] ((::EUTFile*)p);
   }
   static void destruct_EUTFile(void *p) {
      typedef ::EUTFile current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::EUTFile

namespace ROOT {
   // Wrappers around operator new
   static void *new_generic_plane(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::generic_plane : new ::generic_plane;
   }
   static void *newArray_generic_plane(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::generic_plane[nElements] : new ::generic_plane[nElements];
   }
   // Wrapper around operator delete
   static void delete_generic_plane(void *p) {
      delete ((::generic_plane*)p);
   }
   static void deleteArray_generic_plane(void *p) {
      delete [] ((::generic_plane*)p);
   }
   static void destruct_generic_plane(void *p) {
      typedef ::generic_plane current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::generic_plane

namespace ROOT {
   // Wrapper around operator delete
   static void delete_processor(void *p) {
      delete ((::processor*)p);
   }
   static void deleteArray_processor(void *p) {
      delete [] ((::processor*)p);
   }
   static void destruct_processor(void *p) {
      typedef ::processor current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::processor

namespace ROOT {
   // Wrappers around operator new
   static void *new_ProcessorCollection(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ProcessorCollection : new ::ProcessorCollection;
   }
   static void *newArray_ProcessorCollection(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ProcessorCollection[nElements] : new ::ProcessorCollection[nElements];
   }
   // Wrapper around operator delete
   static void delete_ProcessorCollection(void *p) {
      delete ((::ProcessorCollection*)p);
   }
   static void deleteArray_ProcessorCollection(void *p) {
      delete [] ((::ProcessorCollection*)p);
   }
   static void destruct_ProcessorCollection(void *p) {
      typedef ::ProcessorCollection current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ProcessorCollection

namespace ROOT {
   // Wrapper around operator delete
   static void delete_processorPlaneVSPlane(void *p) {
      delete ((::processorPlaneVSPlane*)p);
   }
   static void deleteArray_processorPlaneVSPlane(void *p) {
      delete [] ((::processorPlaneVSPlane*)p);
   }
   static void destruct_processorPlaneVSPlane(void *p) {
      typedef ::processorPlaneVSPlane current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::processorPlaneVSPlane

namespace ROOT {
   // Wrappers around operator new
   static void *new_processor_prob(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::processor_prob : new ::processor_prob;
   }
   static void *newArray_processor_prob(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::processor_prob[nElements] : new ::processor_prob[nElements];
   }
   // Wrapper around operator delete
   static void delete_processor_prob(void *p) {
      delete ((::processor_prob*)p);
   }
   static void deleteArray_processor_prob(void *p) {
      delete [] ((::processor_prob*)p);
   }
   static void destruct_processor_prob(void *p) {
      typedef ::processor_prob current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::processor_prob

namespace ROOT {
   // Wrappers around operator new
   static void *new_Xladder(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Xladder : new ::Xladder;
   }
   static void *newArray_Xladder(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Xladder[nElements] : new ::Xladder[nElements];
   }
   // Wrapper around operator delete
   static void delete_Xladder(void *p) {
      delete ((::Xladder*)p);
   }
   static void deleteArray_Xladder(void *p) {
      delete [] ((::Xladder*)p);
   }
   static void destruct_Xladder(void *p) {
      typedef ::Xladder current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Xladder

namespace ROOT {
   // Wrappers around operator new
   static void *new_Xsensitive(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Xsensitive : new ::Xsensitive;
   }
   static void *newArray_Xsensitive(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Xsensitive[nElements] : new ::Xsensitive[nElements];
   }
   // Wrapper around operator delete
   static void delete_Xsensitive(void *p) {
      delete ((::Xsensitive*)p);
   }
   static void deleteArray_Xsensitive(void *p) {
      delete [] ((::Xsensitive*)p);
   }
   static void destruct_Xsensitive(void *p) {
      typedef ::Xsensitive current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Xsensitive

namespace ROOT {
   // Wrapper around operator delete
   static void delete_Xlayer(void *p) {
      delete ((::Xlayer*)p);
   }
   static void deleteArray_Xlayer(void *p) {
      delete [] ((::Xlayer*)p);
   }
   static void destruct_Xlayer(void *p) {
      typedef ::Xlayer current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Xlayer

namespace ROOT {
   // Wrappers around operator new
   static void *new_Xdetector(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Xdetector : new ::Xdetector;
   }
   static void *newArray_Xdetector(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Xdetector[nElements] : new ::Xdetector[nElements];
   }
   // Wrapper around operator delete
   static void delete_Xdetector(void *p) {
      delete ((::Xdetector*)p);
   }
   static void deleteArray_Xdetector(void *p) {
      delete [] ((::Xdetector*)p);
   }
   static void destruct_Xdetector(void *p) {
      typedef ::Xdetector current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Xdetector

namespace ROOT {
   // Wrappers around operator new
   static void *new_XBField(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::XBField : new ::XBField;
   }
   static void *newArray_XBField(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::XBField[nElements] : new ::XBField[nElements];
   }
   // Wrapper around operator delete
   static void delete_XBField(void *p) {
      delete ((::XBField*)p);
   }
   static void deleteArray_XBField(void *p) {
      delete [] ((::XBField*)p);
   }
   static void destruct_XBField(void *p) {
      typedef ::XBField current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::XBField

namespace ROOT {
   // Wrappers around operator new
   static void *new_Xgear(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Xgear : new ::Xgear;
   }
   static void *newArray_Xgear(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::Xgear[nElements] : new ::Xgear[nElements];
   }
   // Wrapper around operator delete
   static void delete_Xgear(void *p) {
      delete ((::Xgear*)p);
   }
   static void deleteArray_Xgear(void *p) {
      delete [] ((::Xgear*)p);
   }
   static void destruct_Xgear(void *p) {
      typedef ::Xgear current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::Xgear

namespace ROOT {
   // Wrappers around operator new
   static void *new_MinMaxRange(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::MinMaxRange : new ::MinMaxRange;
   }
   static void *newArray_MinMaxRange(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::MinMaxRange[nElements] : new ::MinMaxRange[nElements];
   }
   // Wrapper around operator delete
   static void delete_MinMaxRange(void *p) {
      delete ((::MinMaxRange*)p);
   }
   static void deleteArray_MinMaxRange(void *p) {
      delete [] ((::MinMaxRange*)p);
   }
   static void destruct_MinMaxRange(void *p) {
      typedef ::MinMaxRange current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::MinMaxRange

namespace ROOT {
   // Wrappers around operator new
   static void *new_xml_globalConfig(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::xml_globalConfig : new ::xml_globalConfig;
   }
   static void *newArray_xml_globalConfig(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::xml_globalConfig[nElements] : new ::xml_globalConfig[nElements];
   }
   // Wrapper around operator delete
   static void delete_xml_globalConfig(void *p) {
      delete ((::xml_globalConfig*)p);
   }
   static void deleteArray_xml_globalConfig(void *p) {
      delete [] ((::xml_globalConfig*)p);
   }
   static void destruct_xml_globalConfig(void *p) {
      typedef ::xml_globalConfig current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::xml_globalConfig

namespace ROOT {
   // Wrappers around operator new
   static void *new_xml_file(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::xml_file : new ::xml_file;
   }
   static void *newArray_xml_file(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::xml_file[nElements] : new ::xml_file[nElements];
   }
   // Wrapper around operator delete
   static void delete_xml_file(void *p) {
      delete ((::xml_file*)p);
   }
   static void deleteArray_xml_file(void *p) {
      delete [] ((::xml_file*)p);
   }
   static void destruct_xml_file(void *p) {
      typedef ::xml_file current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::xml_file

namespace ROOT {
   // Wrapper around operator delete
   static void delete_XML_imput_file(void *p) {
      delete ((::XML_imput_file*)p);
   }
   static void deleteArray_XML_imput_file(void *p) {
      delete [] ((::XML_imput_file*)p);
   }
   static void destruct_XML_imput_file(void *p) {
      typedef ::XML_imput_file current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::XML_imput_file

namespace ROOT {
   // Wrappers around operator new
   static void *new_S_Cut(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::S_Cut : new ::S_Cut;
   }
   static void *newArray_S_Cut(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::S_Cut[nElements] : new ::S_Cut[nElements];
   }
   // Wrapper around operator delete
   static void delete_S_Cut(void *p) {
      delete ((::S_Cut*)p);
   }
   static void deleteArray_S_Cut(void *p) {
      delete [] ((::S_Cut*)p);
   }
   static void destruct_S_Cut(void *p) {
      typedef ::S_Cut current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::S_Cut

namespace ROOT {
   // Wrapper around operator delete
   static void delete_S_YCut(void *p) {
      delete ((::S_YCut*)p);
   }
   static void deleteArray_S_YCut(void *p) {
      delete [] ((::S_YCut*)p);
   }
   static void destruct_S_YCut(void *p) {
      typedef ::S_YCut current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::S_YCut

namespace ROOT {
   // Wrapper around operator delete
   static void delete_S_XCut(void *p) {
      delete ((::S_XCut*)p);
   }
   static void deleteArray_S_XCut(void *p) {
      delete [] ((::S_XCut*)p);
   }
   static void destruct_S_XCut(void *p) {
      typedef ::S_XCut current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::S_XCut

namespace ROOT {
   // Wrappers around operator new
   static void *new_S_CutCoollection(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::S_CutCoollection : new ::S_CutCoollection;
   }
   static void *newArray_S_CutCoollection(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::S_CutCoollection[nElements] : new ::S_CutCoollection[nElements];
   }
   // Wrapper around operator delete
   static void delete_S_CutCoollection(void *p) {
      delete ((::S_CutCoollection*)p);
   }
   static void deleteArray_S_CutCoollection(void *p) {
      delete [] ((::S_CutCoollection*)p);
   }
   static void destruct_S_CutCoollection(void *p) {
      typedef ::S_CutCoollection current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::S_CutCoollection

namespace ROOT {
   // Wrapper around operator delete
   static void delete_S_Cut_BinContent(void *p) {
      delete ((::S_Cut_BinContent*)p);
   }
   static void deleteArray_S_Cut_BinContent(void *p) {
      delete [] ((::S_Cut_BinContent*)p);
   }
   static void destruct_S_Cut_BinContent(void *p) {
      typedef ::S_Cut_BinContent current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::S_Cut_BinContent

namespace ROOT {
   // Wrappers around operator new
   static void *new_S_NoCut(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::S_NoCut : new ::S_NoCut;
   }
   static void *newArray_S_NoCut(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::S_NoCut[nElements] : new ::S_NoCut[nElements];
   }
   // Wrapper around operator delete
   static void delete_S_NoCut(void *p) {
      delete ((::S_NoCut*)p);
   }
   static void deleteArray_S_NoCut(void *p) {
      delete [] ((::S_NoCut*)p);
   }
   static void destruct_S_NoCut(void *p) {
      typedef ::S_NoCut current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::S_NoCut

namespace ROOT {
   // Wrappers around operator new
   static void *new_DrawOption(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DrawOption : new ::DrawOption;
   }
   static void *newArray_DrawOption(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::DrawOption[nElements] : new ::DrawOption[nElements];
   }
   // Wrapper around operator delete
   static void delete_DrawOption(void *p) {
      delete ((::DrawOption*)p);
   }
   static void deleteArray_DrawOption(void *p) {
      delete [] ((::DrawOption*)p);
   }
   static void destruct_DrawOption(void *p) {
      typedef ::DrawOption current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::DrawOption

/********************************************************
* DictOutput.cxx
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

extern "C" void G__cpp_reset_tagtableDictOutput();

extern "C" void G__set_cpp_environmentDictOutput() {
  G__add_ipath(".");
  G__add_ipath("..\\..\\include");
  G__cpp_reset_tagtableDictOutput();
}
#include <new>
extern "C" int G__cpp_dllrevDictOutput() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* ProcessorCollection */
static int G__DictOutput_251_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ProcessorCollection* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ProcessorCollection[n];
     } else {
       p = new((void*) gvp) ProcessorCollection[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ProcessorCollection;
     } else {
       p = new((void*) gvp) ProcessorCollection;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_ProcessorCollection));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_251_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((ProcessorCollection*) G__getstructoffset())->init());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_251_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((ProcessorCollection*) G__getstructoffset())->end());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_251_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ProcessorCollection*) G__getstructoffset())->loop();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_251_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ProcessorCollection*) G__getstructoffset())->loop((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_251_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ProcessorCollection*) G__getstructoffset())->next());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_251_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((ProcessorCollection*) G__getstructoffset())->next_debug());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_251_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ProcessorCollection* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ProcessorCollection(*(ProcessorCollection*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_ProcessorCollection));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ProcessorCollection G__TProcessorCollection;
static int G__DictOutput_251_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ProcessorCollection*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ProcessorCollection*) (soff+(sizeof(ProcessorCollection)*i)))->~G__TProcessorCollection();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ProcessorCollection*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ProcessorCollection*) (soff))->~G__TProcessorCollection();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_251_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ProcessorCollection* dest = (ProcessorCollection*) G__getstructoffset();
   const ProcessorCollection& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* axis */
static int G__DictOutput_253_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   axis* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new axis(*(axis*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) axis(*(axis*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_axis));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_253_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const axis& obj = ((axis*) G__getstructoffset())->operator=(*(axis*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_253_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const axis*) G__getstructoffset())->getValue());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_253_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((axis*) G__getstructoffset())->next());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_253_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const axis*) G__getstructoffset())->get_ProcessorCollection());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_253_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const axis*) G__getstructoffset())->get_tree());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_253_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const axis*) G__getstructoffset())->get_ID());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef axis G__Taxis;
static int G__DictOutput_253_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (axis*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((axis*) (soff+(sizeof(axis)*i)))->~G__Taxis();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (axis*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((axis*) (soff))->~G__Taxis();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* generic_plane */
static int G__DictOutput_254_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   generic_plane* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new generic_plane(*(generic_plane*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) generic_plane(*(generic_plane*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_generic_plane));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_254_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const generic_plane& obj = ((generic_plane*) G__getstructoffset())->operator=(*(generic_plane*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_254_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   generic_plane* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new generic_plane[n];
     } else {
       p = new((void*) gvp) generic_plane[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new generic_plane;
     } else {
       p = new((void*) gvp) generic_plane;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_generic_plane));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_254_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((generic_plane*) G__getstructoffset())->add_axis(*(string*) libp->para[0].ref, (vector<double>*) G__int(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_254_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((generic_plane*) G__getstructoffset())->setHitAxisAdress(*(string*) libp->para[0].ref, (double*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_254_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((generic_plane*) G__getstructoffset())->next());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_254_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((generic_plane*) G__getstructoffset())->push();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_254_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((generic_plane*) G__getstructoffset())->push((double) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_254_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const axis* pobj;
         const axis xobj = ((const generic_plane*) G__getstructoffset())->get_axis(*(string*) libp->para[0].ref);
         pobj = new axis(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_254_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const generic_plane*) G__getstructoffset())->get_ProcessorCollection());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_254_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((generic_plane*) G__getstructoffset())->get_tree());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_254_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const generic_plane*) G__getstructoffset())->get_ID());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef generic_plane G__Tgeneric_plane;
static int G__DictOutput_254_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (generic_plane*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((generic_plane*) (soff+(sizeof(generic_plane)*i)))->~G__Tgeneric_plane();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (generic_plane*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((generic_plane*) (soff))->~G__Tgeneric_plane();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* processor_prob */
static int G__DictOutput_255_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const processor_prob& obj = ((processor_prob*) G__getstructoffset())->save2Disk();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_255_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const processor_prob& obj = ((processor_prob*) G__getstructoffset())->dontSave2Disk();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_255_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const processor_prob& obj = ((processor_prob*) G__getstructoffset())->setName(*(string*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_255_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const processor_prob& obj = ((processor_prob*) G__getstructoffset())->addAxis(*(string*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_255_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const processor_prob& obj = ((processor_prob*) G__getstructoffset())->setAxis(*(vector<std::string>*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_255_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const processor_prob& obj = ((processor_prob*) G__getstructoffset())->setProcessorCollection((ProcessorCollection*) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__DictOutput_255_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   processor_prob *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new processor_prob[n];
     } else {
       p = new((void*) gvp) processor_prob[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new processor_prob;
     } else {
       p = new((void*) gvp) processor_prob;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_processor_prob));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_255_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   processor_prob* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new processor_prob(*(processor_prob*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_processor_prob));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef processor_prob G__Tprocessor_prob;
static int G__DictOutput_255_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (processor_prob*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((processor_prob*) (soff+(sizeof(processor_prob)*i)))->~G__Tprocessor_prob();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (processor_prob*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((processor_prob*) (soff))->~G__Tprocessor_prob();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_255_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   processor_prob* dest = (processor_prob*) G__getstructoffset();
   *dest = *(processor_prob*) libp->para[0].ref;
   const processor_prob& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* collection */
static int G__DictOutput_258_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   collection* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new collection((TTree*) G__int(libp->para[0]), (ProcessorCollection*) G__int(libp->para[1]));
   } else {
     p = new((void*) gvp) collection((TTree*) G__int(libp->para[0]), (ProcessorCollection*) G__int(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_collection));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_258_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   collection* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new collection(
*(string*) libp->para[0].ref, *(vector<std::string>*) libp->para[1].ref
, (ProcessorCollection*) G__int(libp->para[2]), (SaveOption) G__int(libp->para[3]));
     } else {
       p = new((void*) gvp) collection(
*(string*) libp->para[0].ref, *(vector<std::string>*) libp->para[1].ref
, (ProcessorCollection*) G__int(libp->para[2]), (SaveOption) G__int(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new collection(
*(string*) libp->para[0].ref, *(vector<std::string>*) libp->para[1].ref
, (ProcessorCollection*) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) collection(
*(string*) libp->para[0].ref, *(vector<std::string>*) libp->para[1].ref
, (ProcessorCollection*) G__int(libp->para[2]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_collection));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_258_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   collection* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new collection(*(processor_prob*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) collection(*(processor_prob*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_collection));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_258_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   collection* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new collection(*(collection*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) collection(*(collection*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_collection));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_258_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const collection& obj = ((collection*) G__getstructoffset())->operator=(*(collection*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_258_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         generic_plane* pobj;
         generic_plane xobj = ((collection*) G__getstructoffset())->getPlane((double) G__double(libp->para[0]));
         pobj = new generic_plane(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_258_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         axis* pobj;
         axis xobj = ((collection*) G__getstructoffset())->getAxis((double) G__double(libp->para[0]), *(string*) libp->para[1].ref);
         pobj = new axis(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_258_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((collection*) G__getstructoffset())->set_Event_Nr((int) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_258_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const collection*) G__getstructoffset())->get_Event_Nr());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_258_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((collection*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_258_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((collection*) G__getstructoffset())->save();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_258_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = ((collection*) G__getstructoffset())->get_name();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_258_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((collection*) G__getstructoffset())->get_ProcessorCollection());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_258_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((collection*) G__getstructoffset())->get_tree());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef collection G__Tcollection;
static int G__DictOutput_258_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (collection*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((collection*) (soff+(sizeof(collection)*i)))->~G__Tcollection();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (collection*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((collection*) (soff))->~G__Tcollection();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* EUTFile */
static int G__DictOutput_269_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EUTFile* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new EUTFile((TFile*) G__int(libp->para[0]), (ProcessorCollection*) G__int(libp->para[1]));
   } else {
     p = new((void*) gvp) EUTFile((TFile*) G__int(libp->para[0]), (ProcessorCollection*) G__int(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_EUTFile));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_269_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((EUTFile*) G__getstructoffset())->getCollection((const char*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_269_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((EUTFile*) G__getstructoffset())->getProcessorCollection());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_269_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   EUTFile* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new EUTFile(*(EUTFile*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_EUTFile));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef EUTFile G__TEUTFile;
static int G__DictOutput_269_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (EUTFile*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((EUTFile*) (soff+(sizeof(EUTFile)*i)))->~G__TEUTFile();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (EUTFile*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((EUTFile*) (soff))->~G__TEUTFile();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_269_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   EUTFile* dest = (EUTFile*) G__getstructoffset();
   const EUTFile& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* processor */
static int G__DictOutput_273_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((processor*) G__getstructoffset())->init());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_273_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((processor*) G__getstructoffset())->processEvent());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_273_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((processor*) G__getstructoffset())->fill());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_273_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((processor*) G__getstructoffset())->end());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_273_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = ((processor*) G__getstructoffset())->get_name();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_273_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = ((processor*) G__getstructoffset())->get_lastError();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_273_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((processor*) G__getstructoffset())->addError(*(string*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_273_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((processor*) G__getstructoffset())->resetErrors();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef processor G__Tprocessor;
static int G__DictOutput_273_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (processor*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((processor*) (soff+(sizeof(processor)*i)))->~G__Tprocessor();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (processor*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((processor*) (soff))->~G__Tprocessor();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_273_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   processor* dest = (processor*) G__getstructoffset();
   *dest = *(processor*) libp->para[0].ref;
   const processor& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* hit */
static int G__DictOutput_274_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   hit* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new hit((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) hit((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new hit((double) G__double(libp->para[0]));
     } else {
       p = new((void*) gvp) hit((double) G__double(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new hit[n];
       } else {
         p = new((void*) gvp) hit[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new hit;
       } else {
         p = new((void*) gvp) hit;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_hit));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_274_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   hit* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new hit(*(hit*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_hit));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef hit G__Thit;
static int G__DictOutput_274_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (hit*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((hit*) (soff+(sizeof(hit)*i)))->~G__Thit();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (hit*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((hit*) (soff))->~G__Thit();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_274_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   hit* dest = (hit*) G__getstructoffset();
   *dest = *(hit*) libp->para[0].ref;
   const hit& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* fitterHit */
static int G__DictOutput_275_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   fitterHit* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 6:
     //m: 6
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new fitterHit(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5]));
     } else {
       p = new((void*) gvp) fitterHit(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]), (double) G__double(libp->para[5]));
     }
     break;
   case 5:
     //m: 5
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new fitterHit(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]));
     } else {
       p = new((void*) gvp) fitterHit(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3])
, (double) G__double(libp->para[4]));
     }
     break;
   case 4:
     //m: 4
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new fitterHit(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
     } else {
       p = new((void*) gvp) fitterHit(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]), (double) G__double(libp->para[3]));
     }
     break;
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new fitterHit(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     } else {
       p = new((void*) gvp) fitterHit(
(double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new fitterHit((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     } else {
       p = new((void*) gvp) fitterHit((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new fitterHit((double) G__double(libp->para[0]));
     } else {
       p = new((void*) gvp) fitterHit((double) G__double(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new fitterHit[n];
       } else {
         p = new((void*) gvp) fitterHit[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new fitterHit;
       } else {
         p = new((void*) gvp) fitterHit;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_fitterHit));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_275_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   fitterHit* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new fitterHit(*(fitterHit*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_fitterHit));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef fitterHit G__TfitterHit;
static int G__DictOutput_275_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (fitterHit*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((fitterHit*) (soff+(sizeof(fitterHit)*i)))->~G__TfitterHit();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (fitterHit*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((fitterHit*) (soff))->~G__TfitterHit();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_275_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   fitterHit* dest = (fitterHit*) G__getstructoffset();
   *dest = *(fitterHit*) libp->para[0].ref;
   const fitterHit& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* plane */
static int G__DictOutput_276_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((plane*) G__getstructoffset())->get_hit());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_276_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((plane*) G__getstructoffset())->next());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_276_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const plane*) G__getstructoffset())->get_ProcessorCollection());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_276_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const plane*) G__getstructoffset())->get_generic_plane());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_276_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((plane*) G__getstructoffset())->get_generic_plane());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef plane G__Tplane;
static int G__DictOutput_276_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (plane*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((plane*) (soff+(sizeof(plane)*i)))->~G__Tplane();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (plane*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((plane*) (soff))->~G__Tplane();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_276_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   plane* dest = (plane*) G__getstructoffset();
   *dest = *(plane*) libp->para[0].ref;
   const plane& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* xy_plane */
static int G__DictOutput_277_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   xy_plane* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new xy_plane(*(generic_plane*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) xy_plane(*(generic_plane*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_xy_plane));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_277_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   xy_plane* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new xy_plane[n];
     } else {
       p = new((void*) gvp) xy_plane[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new xy_plane;
     } else {
       p = new((void*) gvp) xy_plane;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_xy_plane));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_277_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const axis* pobj;
         const axis xobj = ((const xy_plane*) G__getstructoffset())->get_x();
         pobj = new axis(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_277_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const axis* pobj;
         const axis xobj = ((const xy_plane*) G__getstructoffset())->get_y();
         pobj = new axis(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_277_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   xy_plane* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new xy_plane(*(xy_plane*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_xy_plane));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef xy_plane G__Txy_plane;
static int G__DictOutput_277_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (xy_plane*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((xy_plane*) (soff+(sizeof(xy_plane)*i)))->~G__Txy_plane();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (xy_plane*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((xy_plane*) (soff))->~G__Txy_plane();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_277_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   xy_plane* dest = (xy_plane*) G__getstructoffset();
   *dest = *(xy_plane*) libp->para[0].ref;
   const xy_plane& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* FitterPlane */
static int G__DictOutput_278_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FitterPlane* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new FitterPlane(*(generic_plane*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) FitterPlane(*(generic_plane*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_FitterPlane));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_278_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FitterPlane* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FitterPlane[n];
     } else {
       p = new((void*) gvp) FitterPlane[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new FitterPlane;
     } else {
       p = new((void*) gvp) FitterPlane;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_FitterPlane));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_278_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((FitterPlane*) G__getstructoffset())->get_fitterHit());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_278_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   FitterPlane* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new FitterPlane(*(FitterPlane*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_FitterPlane));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef FitterPlane G__TFitterPlane;
static int G__DictOutput_278_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (FitterPlane*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((FitterPlane*) (soff+(sizeof(FitterPlane)*i)))->~G__TFitterPlane();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (FitterPlane*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((FitterPlane*) (soff))->~G__TFitterPlane();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_278_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   FitterPlane* dest = (FitterPlane*) G__getstructoffset();
   *dest = *(FitterPlane*) libp->para[0].ref;
   const FitterPlane& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* processorPlaneVSPlane */
static int G__DictOutput_279_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   processorPlaneVSPlane* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 3
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new processorPlaneVSPlane(
*(xy_plane*) libp->para[0].ref, *(xy_plane*) libp->para[1].ref
, *(processor_prob*) libp->para[2].ref);
   } else {
     p = new((void*) gvp) processorPlaneVSPlane(
*(xy_plane*) libp->para[0].ref, *(xy_plane*) libp->para[1].ref
, *(processor_prob*) libp->para[2].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_processorPlaneVSPlane));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_279_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((processorPlaneVSPlane*) G__getstructoffset())->processEventStart();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_279_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((processorPlaneVSPlane*) G__getstructoffset())->processHit(*(hit*) libp->para[0].ref, *(hit*) libp->para[1].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_279_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((processorPlaneVSPlane*) G__getstructoffset())->processHit_1(*(hit*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_279_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((processorPlaneVSPlane*) G__getstructoffset())->processHit_2(*(hit*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_279_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((processorPlaneVSPlane*) G__getstructoffset())->processEventEnd());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_279_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 3:
      ((processorPlaneVSPlane*) G__getstructoffset())->pushHit((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2]));
      G__setnull(result7);
      break;
   case 2:
      ((processorPlaneVSPlane*) G__getstructoffset())->pushHit((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
      G__setnull(result7);
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_279_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((processorPlaneVSPlane*) G__getstructoffset())->pushHit(*(hit*) libp->para[0].ref, (double) G__double(libp->para[1]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_279_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((processorPlaneVSPlane*) G__getstructoffset())->get_output_collection());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_279_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   processorPlaneVSPlane* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new processorPlaneVSPlane(*(processorPlaneVSPlane*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_processorPlaneVSPlane));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef processorPlaneVSPlane G__TprocessorPlaneVSPlane;
static int G__DictOutput_279_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (processorPlaneVSPlane*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((processorPlaneVSPlane*) (soff+(sizeof(processorPlaneVSPlane)*i)))->~G__TprocessorPlaneVSPlane();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (processorPlaneVSPlane*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((processorPlaneVSPlane*) (soff))->~G__TprocessorPlaneVSPlane();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_279_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   processorPlaneVSPlane* dest = (processorPlaneVSPlane*) G__getstructoffset();
   *dest = *(processorPlaneVSPlane*) libp->para[0].ref;
   const processorPlaneVSPlane& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Xladder */
static int G__DictOutput_281_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Xladder* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Xladder((rapid_xml_node*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) Xladder((rapid_xml_node*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_Xladder));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_281_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Xladder* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Xladder[n];
     } else {
       p = new((void*) gvp) Xladder[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Xladder;
     } else {
       p = new((void*) gvp) Xladder;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_Xladder));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_281_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Xladder* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Xladder(*(Xladder*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_Xladder));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Xladder G__TXladder;
static int G__DictOutput_281_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Xladder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Xladder*) (soff+(sizeof(Xladder)*i)))->~G__TXladder();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Xladder*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Xladder*) (soff))->~G__TXladder();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_281_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Xladder* dest = (Xladder*) G__getstructoffset();
   *dest = *(Xladder*) libp->para[0].ref;
   const Xladder& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Xsensitive */
static int G__DictOutput_282_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Xsensitive* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Xsensitive((rapid_xml_node*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) Xsensitive((rapid_xml_node*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_Xsensitive));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_282_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Xsensitive* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Xsensitive[n];
     } else {
       p = new((void*) gvp) Xsensitive[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Xsensitive;
     } else {
       p = new((void*) gvp) Xsensitive;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_Xsensitive));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_282_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Xsensitive* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Xsensitive(*(Xsensitive*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_Xsensitive));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Xsensitive G__TXsensitive;
static int G__DictOutput_282_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Xsensitive*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Xsensitive*) (soff+(sizeof(Xsensitive)*i)))->~G__TXsensitive();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Xsensitive*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Xsensitive*) (soff))->~G__TXsensitive();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_282_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Xsensitive* dest = (Xsensitive*) G__getstructoffset();
   *dest = *(Xsensitive*) libp->para[0].ref;
   const Xsensitive& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Xlayer */
static int G__DictOutput_283_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Xlayer* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Xlayer((rapid_xml_node*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) Xlayer((rapid_xml_node*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_Xlayer));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_283_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) Xlayer::NodeName());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_283_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Xlayer* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Xlayer(*(Xlayer*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_Xlayer));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Xlayer G__TXlayer;
static int G__DictOutput_283_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Xlayer*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Xlayer*) (soff+(sizeof(Xlayer)*i)))->~G__TXlayer();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Xlayer*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Xlayer*) (soff))->~G__TXlayer();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_283_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Xlayer* dest = (Xlayer*) G__getstructoffset();
   *dest = *(Xlayer*) libp->para[0].ref;
   const Xlayer& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Xdetector */
static int G__DictOutput_284_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Xdetector* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Xdetector((rapid_xml_node*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) Xdetector((rapid_xml_node*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_Xdetector));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_284_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Xdetector* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Xdetector[n];
     } else {
       p = new((void*) gvp) Xdetector[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Xdetector;
     } else {
       p = new((void*) gvp) Xdetector;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_Xdetector));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_284_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((Xdetector*) G__getstructoffset())->layer_by_ID((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_284_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const Xdetector*) G__getstructoffset())->layer_by_ID((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_284_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Xdetector* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Xdetector(*(Xdetector*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_Xdetector));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Xdetector G__TXdetector;
static int G__DictOutput_284_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Xdetector*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Xdetector*) (soff+(sizeof(Xdetector)*i)))->~G__TXdetector();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Xdetector*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Xdetector*) (soff))->~G__TXdetector();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_284_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Xdetector* dest = (Xdetector*) G__getstructoffset();
   *dest = *(Xdetector*) libp->para[0].ref;
   const Xdetector& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* XBField */
static int G__DictOutput_294_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   XBField* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new XBField((rapid_xml_node*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) XBField((rapid_xml_node*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_XBField));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_294_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   XBField* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new XBField[n];
     } else {
       p = new((void*) gvp) XBField[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new XBField;
     } else {
       p = new((void*) gvp) XBField;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_XBField));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_294_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   XBField* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new XBField(*(XBField*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_XBField));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef XBField G__TXBField;
static int G__DictOutput_294_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (XBField*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((XBField*) (soff+(sizeof(XBField)*i)))->~G__TXBField();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (XBField*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((XBField*) (soff))->~G__TXBField();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_294_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   XBField* dest = (XBField*) G__getstructoffset();
   *dest = *(XBField*) libp->para[0].ref;
   const XBField& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Xgear */
static int G__DictOutput_295_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Xgear* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Xgear((rapid_xml_node*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) Xgear((rapid_xml_node*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_Xgear));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_295_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Xgear* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new Xgear((const char*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) Xgear((const char*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_Xgear));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_295_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Xgear* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Xgear[n];
     } else {
       p = new((void*) gvp) Xgear[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new Xgear;
     } else {
       p = new((void*) gvp) Xgear;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_Xgear));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_295_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   Xgear* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new Xgear(*(Xgear*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_Xgear));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef Xgear G__TXgear;
static int G__DictOutput_295_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (Xgear*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((Xgear*) (soff+(sizeof(Xgear)*i)))->~G__TXgear();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (Xgear*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((Xgear*) (soff))->~G__TXgear();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_295_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   Xgear* dest = (Xgear*) G__getstructoffset();
   *dest = *(Xgear*) libp->para[0].ref;
   const Xgear& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* S_Cut */
static int G__DictOutput_296_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const S_Cut*) G__getstructoffset())->isOutOfRange((double) G__double(libp->para[0]), (double) G__double(libp->para[1])
, (double) G__double(libp->para[2])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_296_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const S_Cut*) G__getstructoffset())->isOutOfRange((double) G__double(libp->para[0]), (double) G__double(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_296_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const S_Cut*) G__getstructoffset())->isOutOfRange((double) G__double(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__DictOutput_296_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   S_Cut *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new S_Cut[n];
     } else {
       p = new((void*) gvp) S_Cut[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new S_Cut;
     } else {
       p = new((void*) gvp) S_Cut;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_S_Cut));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_296_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   S_Cut* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new S_Cut(*(S_Cut*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_S_Cut));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef S_Cut G__TS_Cut;
static int G__DictOutput_296_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (S_Cut*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((S_Cut*) (soff+(sizeof(S_Cut)*i)))->~G__TS_Cut();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (S_Cut*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((S_Cut*) (soff))->~G__TS_Cut();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_296_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   S_Cut* dest = (S_Cut*) G__getstructoffset();
   *dest = *(S_Cut*) libp->para[0].ref;
   const S_Cut& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* S_NoCut */
// automatic default constructor
static int G__DictOutput_297_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   S_NoCut *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new S_NoCut[n];
     } else {
       p = new((void*) gvp) S_NoCut[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new S_NoCut;
     } else {
       p = new((void*) gvp) S_NoCut;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_S_NoCut));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_297_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   S_NoCut* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new S_NoCut(*(S_NoCut*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_S_NoCut));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef S_NoCut G__TS_NoCut;
static int G__DictOutput_297_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (S_NoCut*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((S_NoCut*) (soff+(sizeof(S_NoCut)*i)))->~G__TS_NoCut();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (S_NoCut*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((S_NoCut*) (soff))->~G__TS_NoCut();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_297_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   S_NoCut* dest = (S_NoCut*) G__getstructoffset();
   *dest = *(S_NoCut*) libp->para[0].ref;
   const S_NoCut& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* S_XCut */
static int G__DictOutput_299_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   S_XCut* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new S_XCut((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
   } else {
     p = new((void*) gvp) S_XCut((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_S_XCut));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_299_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   S_XCut* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new S_XCut((double) G__double(libp->para[0]));
   } else {
     p = new((void*) gvp) S_XCut((double) G__double(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_S_XCut));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_299_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   S_XCut* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new S_XCut(*(S_XCut*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_S_XCut));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef S_XCut G__TS_XCut;
static int G__DictOutput_299_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (S_XCut*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((S_XCut*) (soff+(sizeof(S_XCut)*i)))->~G__TS_XCut();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (S_XCut*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((S_XCut*) (soff))->~G__TS_XCut();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_299_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   S_XCut* dest = (S_XCut*) G__getstructoffset();
   *dest = *(S_XCut*) libp->para[0].ref;
   const S_XCut& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* S_YCut */
static int G__DictOutput_300_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   S_YCut* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new S_YCut((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
   } else {
     p = new((void*) gvp) S_YCut((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_S_YCut));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_300_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   S_YCut* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new S_YCut((double) G__double(libp->para[0]));
   } else {
     p = new((void*) gvp) S_YCut((double) G__double(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_S_YCut));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_300_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   S_YCut* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new S_YCut(*(S_YCut*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_S_YCut));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef S_YCut G__TS_YCut;
static int G__DictOutput_300_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (S_YCut*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((S_YCut*) (soff+(sizeof(S_YCut)*i)))->~G__TS_YCut();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (S_YCut*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((S_YCut*) (soff))->~G__TS_YCut();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_300_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   S_YCut* dest = (S_YCut*) G__getstructoffset();
   *dest = *(S_YCut*) libp->para[0].ref;
   const S_YCut& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* S_Cut_BinContent */
static int G__DictOutput_301_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   S_Cut_BinContent* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new S_Cut_BinContent((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
   } else {
     p = new((void*) gvp) S_Cut_BinContent((double) G__double(libp->para[0]), (double) G__double(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_S_Cut_BinContent));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_301_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   S_Cut_BinContent* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new S_Cut_BinContent((double) G__double(libp->para[0]));
   } else {
     p = new((void*) gvp) S_Cut_BinContent((double) G__double(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_S_Cut_BinContent));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_301_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   S_Cut_BinContent* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new S_Cut_BinContent(*(S_Cut_BinContent*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_S_Cut_BinContent));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef S_Cut_BinContent G__TS_Cut_BinContent;
static int G__DictOutput_301_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (S_Cut_BinContent*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((S_Cut_BinContent*) (soff+(sizeof(S_Cut_BinContent)*i)))->~G__TS_Cut_BinContent();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (S_Cut_BinContent*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((S_Cut_BinContent*) (soff))->~G__TS_Cut_BinContent();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_301_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   S_Cut_BinContent* dest = (S_Cut_BinContent*) G__getstructoffset();
   *dest = *(S_Cut_BinContent*) libp->para[0].ref;
   const S_Cut_BinContent& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* S_CutCoollection */
static int G__DictOutput_302_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   S_CutCoollection* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new S_CutCoollection[n];
     } else {
       p = new((void*) gvp) S_CutCoollection[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new S_CutCoollection;
     } else {
       p = new((void*) gvp) S_CutCoollection;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_S_CutCoollection));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_302_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((S_CutCoollection*) G__getstructoffset())->add_Cut(*(S_Cut*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_302_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((S_CutCoollection*) G__getstructoffset())->add_Cut(*(S_CutCoollection*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_302_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   S_CutCoollection* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new S_CutCoollection(*(S_CutCoollection*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_S_CutCoollection));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef S_CutCoollection G__TS_CutCoollection;
static int G__DictOutput_302_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (S_CutCoollection*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((S_CutCoollection*) (soff+(sizeof(S_CutCoollection)*i)))->~G__TS_CutCoollection();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (S_CutCoollection*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((S_CutCoollection*) (soff))->~G__TS_CutCoollection();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_302_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   S_CutCoollection* dest = (S_CutCoollection*) G__getstructoffset();
   *dest = *(S_CutCoollection*) libp->para[0].ref;
   const S_CutCoollection& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* MinMaxRange */
static int G__DictOutput_303_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   MinMaxRange* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new MinMaxRange((int) G__int(libp->para[0]), (int) G__int(libp->para[1]));
   } else {
     p = new((void*) gvp) MinMaxRange((int) G__int(libp->para[0]), (int) G__int(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_MinMaxRange));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_303_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   MinMaxRange* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 3
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new MinMaxRange(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (int) G__int(libp->para[2]));
   } else {
     p = new((void*) gvp) MinMaxRange(
(int) G__int(libp->para[0]), (int) G__int(libp->para[1])
, (int) G__int(libp->para[2]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_MinMaxRange));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_303_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   MinMaxRange* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new MinMaxRange[n];
     } else {
       p = new((void*) gvp) MinMaxRange[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new MinMaxRange;
     } else {
       p = new((void*) gvp) MinMaxRange;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_MinMaxRange));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_303_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const MinMaxRange*) G__getstructoffset())->getMin());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_303_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const MinMaxRange*) G__getstructoffset())->getMax());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_303_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const MinMaxRange*) G__getstructoffset())->getStep());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_303_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   MinMaxRange* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new MinMaxRange(*(MinMaxRange*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_MinMaxRange));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef MinMaxRange G__TMinMaxRange;
static int G__DictOutput_303_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (MinMaxRange*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((MinMaxRange*) (soff+(sizeof(MinMaxRange)*i)))->~G__TMinMaxRange();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (MinMaxRange*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((MinMaxRange*) (soff))->~G__TMinMaxRange();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_303_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   MinMaxRange* dest = (MinMaxRange*) G__getstructoffset();
   *dest = *(MinMaxRange*) libp->para[0].ref;
   const MinMaxRange& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* xml_globalConfig */
static int G__DictOutput_304_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   xml_globalConfig* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new xml_globalConfig((rapid_xml_node*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) xml_globalConfig((rapid_xml_node*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_xml_globalConfig));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_304_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   xml_globalConfig* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new xml_globalConfig[n];
     } else {
       p = new((void*) gvp) xml_globalConfig[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new xml_globalConfig;
     } else {
       p = new((void*) gvp) xml_globalConfig;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_xml_globalConfig));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_304_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const S_Cut& obj = ((const xml_globalConfig*) G__getstructoffset())->cut();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_304_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   xml_globalConfig* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new xml_globalConfig(*(xml_globalConfig*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_xml_globalConfig));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef xml_globalConfig G__Txml_globalConfig;
static int G__DictOutput_304_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (xml_globalConfig*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((xml_globalConfig*) (soff+(sizeof(xml_globalConfig)*i)))->~G__Txml_globalConfig();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (xml_globalConfig*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((xml_globalConfig*) (soff))->~G__Txml_globalConfig();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_304_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   xml_globalConfig* dest = (xml_globalConfig*) G__getstructoffset();
   *dest = *(xml_globalConfig*) libp->para[0].ref;
   const xml_globalConfig& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* xml_file */
static int G__DictOutput_305_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   xml_file* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new xml_file((rapid_xml_node*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) xml_file((rapid_xml_node*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_xml_file));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_305_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) xml_file::NodeName());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_305_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   xml_file* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new xml_file[n];
     } else {
       p = new((void*) gvp) xml_file[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new xml_file;
     } else {
       p = new((void*) gvp) xml_file;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_xml_file));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_305_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   xml_file* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new xml_file(*(xml_file*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_xml_file));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef xml_file G__Txml_file;
static int G__DictOutput_305_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (xml_file*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((xml_file*) (soff+(sizeof(xml_file)*i)))->~G__Txml_file();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (xml_file*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((xml_file*) (soff))->~G__Txml_file();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_305_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   xml_file* dest = (xml_file*) G__getstructoffset();
   *dest = *(xml_file*) libp->para[0].ref;
   const xml_file& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* XML_imput_file */
static int G__DictOutput_306_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   XML_imput_file* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new XML_imput_file((const char*) G__int(libp->para[0]));
   } else {
     p = new((void*) gvp) XML_imput_file((const char*) G__int(libp->para[0]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_XML_imput_file));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_306_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const xml_file& obj = ((XML_imput_file*) G__getstructoffset())->get_File((int) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_306_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const xml_file& obj = ((const XML_imput_file*) G__getstructoffset())->get_File((int) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_306_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((const XML_imput_file*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_306_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   XML_imput_file* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new XML_imput_file(*(XML_imput_file*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_XML_imput_file));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef XML_imput_file G__TXML_imput_file;
static int G__DictOutput_306_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (XML_imput_file*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((XML_imput_file*) (soff+(sizeof(XML_imput_file)*i)))->~G__TXML_imput_file();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (XML_imput_file*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((XML_imput_file*) (soff))->~G__TXML_imput_file();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_306_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   XML_imput_file* dest = (XML_imput_file*) G__getstructoffset();
   *dest = *(XML_imput_file*) libp->para[0].ref;
   const XML_imput_file& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* DrawOption */
static int G__DictOutput_332_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DrawOption* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DrawOption(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) DrawOption(
(const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1])
, (const char*) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DrawOption((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
     } else {
       p = new((void*) gvp) DrawOption((const char*) G__int(libp->para[0]), (const char*) G__int(libp->para[1]));
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DrawOption((const char*) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) DrawOption((const char*) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_DrawOption));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DrawOption* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 3:
     //m: 3
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DrawOption(
(const char*) G__int(libp->para[0]), *((TCut*) G__int(libp->para[1]))
, (const char*) G__int(libp->para[2]));
     } else {
       p = new((void*) gvp) DrawOption(
(const char*) G__int(libp->para[0]), *((TCut*) G__int(libp->para[1]))
, (const char*) G__int(libp->para[2]));
     }
     break;
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DrawOption((const char*) G__int(libp->para[0]), *((TCut*) G__int(libp->para[1])));
     } else {
       p = new((void*) gvp) DrawOption((const char*) G__int(libp->para[0]), *((TCut*) G__int(libp->para[1])));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_DrawOption));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DrawOption* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DrawOption[n];
     } else {
       p = new((void*) gvp) DrawOption[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new DrawOption;
     } else {
       p = new((void*) gvp) DrawOption;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_DrawOption));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->options((const char*) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->opt_colz();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->opt_star();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->opt_bar();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->opt_same();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->opt_color((Color_t) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->color_red();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->color_white();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->color_black();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->color_gray();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->color_green();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->color_blue();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->color_yellow();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->color_magenta();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->color_cyan();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->color_orange();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->color_spring();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->color_teal();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->color_azure();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->color_violet();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->color_pink();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->cut(*(string*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->cut_min(*(string*) libp->para[0].ref, (Double_t) G__double(libp->para[1]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->cut_max(*(string*) libp->para[0].ref, (Double_t) G__double(libp->para[1]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->cut(*(string*) libp->para[0].ref, (Double_t) G__double(libp->para[1])
, (Double_t) G__double(libp->para[2]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->cut_add(*(TCut*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->cut_x((Double_t) G__double(libp->para[0]), (Double_t) G__double(libp->para[1]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->cut_x_min((Double_t) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->cut_x_max((Double_t) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->cut_y((Double_t) G__double(libp->para[0]), (Double_t) G__double(libp->para[1]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->cut_y_min((Double_t) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->cut_y_max((Double_t) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->draw_axis(*(string*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->draw_axis(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->draw_axis(*(string*) libp->para[0].ref, *(string*) libp->para[1].ref
, *(string*) libp->para[2].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->draw_x();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->draw_y();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->draw_x_VS_y();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->draw_y_VS_x();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const DrawOption& obj = ((DrawOption*) G__getstructoffset())->output_object((TObject*) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const DrawOption*) G__getstructoffset())->get_output_object());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letLonglong(result7, 110, (G__int64) ((const DrawOption*) G__getstructoffset())->Draw((TTree*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const DrawOption*) G__getstructoffset())->getOptions());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 67, (long) ((const DrawOption*) G__getstructoffset())->getAxis());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput_332_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TCut* pobj;
         const TCut xobj = ((const DrawOption*) G__getstructoffset())->getCut();
         pobj = new TCut(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__DictOutput_332_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   DrawOption* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new DrawOption(*(DrawOption*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__DictOutputLN_DrawOption));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef DrawOption G__TDrawOption;
static int G__DictOutput_332_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (DrawOption*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((DrawOption*) (soff+(sizeof(DrawOption)*i)))->~G__TDrawOption();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (DrawOption*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((DrawOption*) (soff))->~G__TDrawOption();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__DictOutput_332_0_51(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   DrawOption* dest = (DrawOption*) G__getstructoffset();
   const DrawOption& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */
static int G__DictOutput__0_439(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         Xgear* pobj;
         Xgear xobj = load_gear((const char*) G__int(libp->para[0]));
         pobj = new Xgear(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput__0_523(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 105, (long) Draw(*(axis*) libp->para[0].ref, *((DrawOption*) G__int(libp->para[1]))));
      break;
   case 1:
      G__letint(result7, 105, (long) Draw(*(axis*) libp->para[0].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput__0_524(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 105, (long) Draw(*(generic_plane*) libp->para[0].ref, *((DrawOption*) G__int(libp->para[1]))));
      break;
   case 1:
      G__letint(result7, 105, (long) Draw(*(generic_plane*) libp->para[0].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__DictOutput__0_525(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 2:
      G__letint(result7, 105, (long) Draw(*(xy_plane*) libp->para[0].ref, *((DrawOption*) G__int(libp->para[1]))));
      break;
   case 1:
      G__letint(result7, 105, (long) Draw(*(xy_plane*) libp->para[0].ref));
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}


/*********************************************************
* Member function Stub
*********************************************************/

/* ProcessorCollection */

/* axis */

/* generic_plane */

/* processor_prob */

/* collection */

/* EUTFile */

/* processor */

/* hit */

/* fitterHit */

/* plane */

/* xy_plane */

/* FitterPlane */

/* processorPlaneVSPlane */

/* Xladder */

/* Xsensitive */

/* Xlayer */

/* Xdetector */

/* XBField */

/* Xgear */

/* S_Cut */

/* S_NoCut */

/* S_XCut */

/* S_YCut */

/* S_Cut_BinContent */

/* S_CutCoollection */

/* MinMaxRange */

/* xml_globalConfig */

/* xml_file */

/* XML_imput_file */

/* DrawOption */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncDictOutput {
 public:
  G__Sizep2memfuncDictOutput(): p(&G__Sizep2memfuncDictOutput::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncDictOutput::*p)();
};

size_t G__get_sizep2memfuncDictOutput()
{
  G__Sizep2memfuncDictOutput a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceDictOutput() {

   /* Setting up class inheritance */
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__DictOutputLN_fitterHit))) {
     fitterHit *G__Lderived;
     G__Lderived=(fitterHit*)0x1000;
     {
       hit *G__Lpbase=(hit*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__DictOutputLN_fitterHit),G__get_linked_tagnum(&G__DictOutputLN_hit),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__DictOutputLN_xy_plane))) {
     xy_plane *G__Lderived;
     G__Lderived=(xy_plane*)0x1000;
     {
       plane *G__Lpbase=(plane*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__DictOutputLN_xy_plane),G__get_linked_tagnum(&G__DictOutputLN_plane),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__DictOutputLN_FitterPlane))) {
     FitterPlane *G__Lderived;
     G__Lderived=(FitterPlane*)0x1000;
     {
       xy_plane *G__Lpbase=(xy_plane*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__DictOutputLN_FitterPlane),G__get_linked_tagnum(&G__DictOutputLN_xy_plane),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       plane *G__Lpbase=(plane*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__DictOutputLN_FitterPlane),G__get_linked_tagnum(&G__DictOutputLN_plane),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__DictOutputLN_processorPlaneVSPlane))) {
     processorPlaneVSPlane *G__Lderived;
     G__Lderived=(processorPlaneVSPlane*)0x1000;
     {
       processor *G__Lpbase=(processor*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__DictOutputLN_processorPlaneVSPlane),G__get_linked_tagnum(&G__DictOutputLN_processor),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__DictOutputLN_S_NoCut))) {
     S_NoCut *G__Lderived;
     G__Lderived=(S_NoCut*)0x1000;
     {
       S_Cut *G__Lpbase=(S_Cut*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__DictOutputLN_S_NoCut),G__get_linked_tagnum(&G__DictOutputLN_S_Cut),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__DictOutputLN_S_XCut))) {
     S_XCut *G__Lderived;
     G__Lderived=(S_XCut*)0x1000;
     {
       S_Cut_min_max *G__Lpbase=(S_Cut_min_max*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__DictOutputLN_S_XCut),G__get_linked_tagnum(&G__DictOutputLN_S_Cut_min_max),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       S_Cut *G__Lpbase=(S_Cut*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__DictOutputLN_S_XCut),G__get_linked_tagnum(&G__DictOutputLN_S_Cut),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__DictOutputLN_S_YCut))) {
     S_YCut *G__Lderived;
     G__Lderived=(S_YCut*)0x1000;
     {
       S_Cut_min_max *G__Lpbase=(S_Cut_min_max*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__DictOutputLN_S_YCut),G__get_linked_tagnum(&G__DictOutputLN_S_Cut_min_max),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       S_Cut *G__Lpbase=(S_Cut*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__DictOutputLN_S_YCut),G__get_linked_tagnum(&G__DictOutputLN_S_Cut),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__DictOutputLN_S_Cut_BinContent))) {
     S_Cut_BinContent *G__Lderived;
     G__Lderived=(S_Cut_BinContent*)0x1000;
     {
       S_Cut_min_max *G__Lpbase=(S_Cut_min_max*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__DictOutputLN_S_Cut_BinContent),G__get_linked_tagnum(&G__DictOutputLN_S_Cut_min_max),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       S_Cut *G__Lpbase=(S_Cut*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__DictOutputLN_S_Cut_BinContent),G__get_linked_tagnum(&G__DictOutputLN_S_Cut),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__DictOutputLN_S_CutCoollection))) {
     S_CutCoollection *G__Lderived;
     G__Lderived=(S_CutCoollection*)0x1000;
     {
       S_Cut *G__Lpbase=(S_Cut*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__DictOutputLN_S_CutCoollection),G__get_linked_tagnum(&G__DictOutputLN_S_Cut),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableDictOutput() {

   /* Setting up typedef entry */
   G__search_typename2("Double_t",100,-1,0,-1);
   G__setnewtype(-1,"Double 8 bytes",0);
   G__search_typename2("Long64_t",110,-1,0,-1);
   G__setnewtype(-1,"Portable signed long integer 8 bytes",0);
   G__search_typename2("Color_t",115,-1,0,-1);
   G__setnewtype(-1,"Color number (short)",0);
   G__search_typename2("iterator<iterator_traits<string::iterator>::iterator_category,iterator_traits<string::iterator>::value_type,iterator_traits<string::iterator>::difference_type,iterator_traits<string::iterator>::pointer,iterator_traits<string::iterator>::reference>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOcharcOlongcOcharmUcOcharaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,char>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOcharcOlongcOcharmUcOcharaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,char,long>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOcharcOlongcOcharmUcOcharaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,char,long,char*>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOcharcOlongcOcharmUcOcharaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<string::const_iterator>::iterator_category,iterator_traits<string::const_iterator>::value_type,iterator_traits<string::const_iterator>::difference_type,iterator_traits<string::const_iterator>::pointer,iterator_traits<string::const_iterator>::reference>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOcharcOlongcOcharmUcOcharaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__DictOutputLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__DictOutputLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictOutputLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictOutputLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>::iterator_category,iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>::value_type,iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>::difference_type,iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>::pointer,iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>::reference>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ROOT::TSchemaHelper,long>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,ROOT::TSchemaHelper,long,ROOT::TSchemaHelper*>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictOutputLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__DictOutputLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::const_iterator>::iterator_category,iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::const_iterator>::value_type,iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::const_iterator>::difference_type,iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::const_iterator>::pointer,iterator_traits<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::const_iterator>::reference>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__DictOutputLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__DictOutputLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictOutputLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictOutputLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>::iterator_category,iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>::value_type,iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>::difference_type,iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>::pointer,iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>::reference>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOTVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,TVirtualArray*>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOTVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,TVirtualArray*,long>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOTVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,TVirtualArray*,long,TVirtualArray**>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOTVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictOutputLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__DictOutputLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::const_iterator>::iterator_category,iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::const_iterator>::value_type,iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::const_iterator>::difference_type,iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::const_iterator>::pointer,iterator_traits<vector<TVirtualArray*,allocator<TVirtualArray*> >::const_iterator>::reference>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOTVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::string>",117,G__get_linked_tagnum(&G__DictOutputLN_vectorlEstringcOallocatorlEstringgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<string>",117,G__get_linked_tagnum(&G__DictOutputLN_vectorlEstringcOallocatorlEstringgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<string>",117,G__get_linked_tagnum(&G__DictOutputLN_vectorlEstringcOallocatorlEstringgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictOutputLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictOutputLN_vectorlEstringcOallocatorlEstringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<string,allocator<string> >::iterator>::iterator_category,iterator_traits<vector<string,allocator<string> >::iterator>::value_type,iterator_traits<vector<string,allocator<string> >::iterator>::difference_type,iterator_traits<vector<string,allocator<string> >::iterator>::pointer,iterator_traits<vector<string,allocator<string> >::iterator>::reference>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOstringcOlongcOstringmUcOstringaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,string>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOstringcOlongcOstringmUcOstringaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,string,long>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOstringcOlongcOstringmUcOstringaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,string,long,string*>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOstringcOlongcOstringmUcOstringaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictOutputLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__DictOutputLN_vectorlEstringcOallocatorlEstringgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<string,allocator<string> >::const_iterator>::iterator_category,iterator_traits<vector<string,allocator<string> >::const_iterator>::value_type,iterator_traits<vector<string,allocator<string> >::const_iterator>::difference_type,iterator_traits<vector<string,allocator<string> >::const_iterator>::pointer,iterator_traits<vector<string,allocator<string> >::const_iterator>::reference>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOstringcOlongcOstringmUcOstringaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Xlayer>",117,G__get_linked_tagnum(&G__DictOutputLN_vectorlEXlayercOallocatorlEXlayergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Xlayer>",117,G__get_linked_tagnum(&G__DictOutputLN_vectorlEXlayercOallocatorlEXlayergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictOutputLN_reverse_iteratorlEvectorlEXlayercOallocatorlEXlayergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictOutputLN_vectorlEXlayercOallocatorlEXlayergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<Xlayer,allocator<Xlayer> >::iterator>::iterator_category,iterator_traits<vector<Xlayer,allocator<Xlayer> >::iterator>::value_type,iterator_traits<vector<Xlayer,allocator<Xlayer> >::iterator>::difference_type,iterator_traits<vector<Xlayer,allocator<Xlayer> >::iterator>::pointer,iterator_traits<vector<Xlayer,allocator<Xlayer> >::iterator>::reference>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOXlayercOlongcOXlayermUcOXlayeraNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,Xlayer>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOXlayercOlongcOXlayermUcOXlayeraNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,Xlayer,long>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOXlayercOlongcOXlayermUcOXlayeraNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,Xlayer,long,Xlayer*>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOXlayercOlongcOXlayermUcOXlayeraNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictOutputLN_reverse_iteratorlEvectorlEXlayercOallocatorlEXlayergRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__DictOutputLN_vectorlEXlayercOallocatorlEXlayergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<Xlayer,allocator<Xlayer> >::const_iterator>::iterator_category,iterator_traits<vector<Xlayer,allocator<Xlayer> >::const_iterator>::value_type,iterator_traits<vector<Xlayer,allocator<Xlayer> >::const_iterator>::difference_type,iterator_traits<vector<Xlayer,allocator<Xlayer> >::const_iterator>::pointer,iterator_traits<vector<Xlayer,allocator<Xlayer> >::const_iterator>::reference>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOXlayercOlongcOXlayermUcOXlayeraNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<xml_file>",117,G__get_linked_tagnum(&G__DictOutputLN_vectorlExml_filecOallocatorlExml_filegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<xml_file>",117,G__get_linked_tagnum(&G__DictOutputLN_vectorlExml_filecOallocatorlExml_filegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__DictOutputLN_reverse_iteratorlEvectorlExml_filecOallocatorlExml_filegRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__DictOutputLN_vectorlExml_filecOallocatorlExml_filegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<xml_file,allocator<xml_file> >::iterator>::iterator_category,iterator_traits<vector<xml_file,allocator<xml_file> >::iterator>::value_type,iterator_traits<vector<xml_file,allocator<xml_file> >::iterator>::difference_type,iterator_traits<vector<xml_file,allocator<xml_file> >::iterator>::pointer,iterator_traits<vector<xml_file,allocator<xml_file> >::iterator>::reference>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOxml_filecOlongcOxml_filemUcOxml_fileaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,xml_file>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOxml_filecOlongcOxml_filemUcOxml_fileaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,xml_file,long>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOxml_filecOlongcOxml_filemUcOxml_fileaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<random_access_iterator_tag,xml_file,long,xml_file*>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOxml_filecOlongcOxml_filemUcOxml_fileaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__DictOutputLN_reverse_iteratorlEvectorlExml_filecOallocatorlExml_filegRsPgRcLcLconst_iteratorgR),0,G__get_linked_tagnum(&G__DictOutputLN_vectorlExml_filecOallocatorlExml_filegRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<iterator_traits<vector<xml_file,allocator<xml_file> >::const_iterator>::iterator_category,iterator_traits<vector<xml_file,allocator<xml_file> >::const_iterator>::value_type,iterator_traits<vector<xml_file,allocator<xml_file> >::const_iterator>::difference_type,iterator_traits<vector<xml_file,allocator<xml_file> >::const_iterator>::pointer,iterator_traits<vector<xml_file,allocator<xml_file> >::const_iterator>::reference>",117,G__get_linked_tagnum(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOxml_filecOlongcOxml_filemUcOxml_fileaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* ProcessorCollection */
static void G__setup_memvarProcessorCollection(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_ProcessorCollection));
   { ProcessorCollection *p; p=(ProcessorCollection*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* axis */
static void G__setup_memvaraxis(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_axis));
   { axis *p; p=(axis*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* generic_plane */
static void G__setup_memvargeneric_plane(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_generic_plane));
   { generic_plane *p; p=(generic_plane*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* processor_prob */
static void G__setup_memvarprocessor_prob(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_processor_prob));
   { processor_prob *p; p=(processor_prob*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->name)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictOutputLN_string),-1,-1,1,"name=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->save)-(long)(p)),105,0,0,G__get_linked_tagnum(&G__DictOutputLN_SaveOption),-1,-1,1,"save=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ProcessorColl)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__DictOutputLN_ProcessorCollection),-1,-1,1,"ProcessorColl=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->axisNames)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictOutputLN_vectorlEstringcOallocatorlEstringgRsPgR),G__defined_typename("vector<std::string>"),-1,1,"axisNames=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* collection */
static void G__setup_memvarcollection(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_collection));
   { collection *p; p=(collection*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* EUTFile */
static void G__setup_memvarEUTFile(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_EUTFile));
   { EUTFile *p; p=(EUTFile*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* processor */
static void G__setup_memvarprocessor(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_processor));
   { processor *p; p=(processor*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->mpc)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__DictOutputLN_ProcessorCollection),-1,-1,1,"mpc=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__DictOutputLN_string),-1,-1,4,"m_errors=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* hit */
static void G__setup_memvarhit(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_hit));
   { hit *p; p=(hit*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),100,0,0,-1,-1,-1,1,"x=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),100,0,0,-1,-1,-1,1,"y=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* fitterHit */
static void G__setup_memvarfitterHit(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_fitterHit));
   { fitterHit *p; p=(fitterHit*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->chi2)-(long)(p)),100,0,0,-1,-1,-1,1,"chi2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ndf)-(long)(p)),100,0,0,-1,-1,-1,1,"ndf=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->theta)-(long)(p)),100,0,0,-1,-1,-1,1,"theta=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->phi)-(long)(p)),100,0,0,-1,-1,-1,1,"phi=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* plane */
static void G__setup_memvarplane(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_plane));
   { plane *p; p=(plane*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__DictOutputLN_generic_plane),-1,-1,2,"m_plane=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* xy_plane */
static void G__setup_memvarxy_plane(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_xy_plane));
   { xy_plane *p; p=(xy_plane*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* FitterPlane */
static void G__setup_memvarFitterPlane(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_FitterPlane));
   { FitterPlane *p; p=(FitterPlane*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* processorPlaneVSPlane */
static void G__setup_memvarprocessorPlaneVSPlane(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_processorPlaneVSPlane));
   { processorPlaneVSPlane *p; p=(processorPlaneVSPlane*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->m_size_x)-(long)(p)),105,0,0,-1,-1,-1,1,"m_size_x=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->m_size_y)-(long)(p)),105,0,0,-1,-1,-1,1,"m_size_y=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->m_current)-(long)(p)),105,0,0,-1,-1,-1,1,"m_current=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Xladder */
static void G__setup_memvarXladder(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_Xladder));
   { Xladder *p; p=(Xladder*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),100,0,0,-1,-1,-1,1,"ID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->positionX)-(long)(p)),100,0,0,-1,-1,-1,1,"positionX=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->positionY)-(long)(p)),100,0,0,-1,-1,-1,1,"positionY=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->positionZ)-(long)(p)),100,0,0,-1,-1,-1,1,"positionZ=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->radLength)-(long)(p)),100,0,0,-1,-1,-1,1,"radLength=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->rotationXY)-(long)(p)),100,0,0,-1,-1,-1,1,"rotationXY=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->rotationZX)-(long)(p)),100,0,0,-1,-1,-1,1,"rotationZX=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->rotationZY)-(long)(p)),100,0,0,-1,-1,-1,1,"rotationZY=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->sizeX)-(long)(p)),100,0,0,-1,-1,-1,1,"sizeX=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->sizeY)-(long)(p)),100,0,0,-1,-1,-1,1,"sizeY=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->thickness)-(long)(p)),100,0,0,-1,-1,-1,1,"thickness=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Xsensitive */
static void G__setup_memvarXsensitive(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_Xsensitive));
   { Xsensitive *p; p=(Xsensitive*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ID)-(long)(p)),100,0,0,-1,-1,-1,1,"ID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->npixelX)-(long)(p)),100,0,0,-1,-1,-1,1,"npixelX=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->npixelY)-(long)(p)),100,0,0,-1,-1,-1,1,"npixelY=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->pitchX)-(long)(p)),100,0,0,-1,-1,-1,1,"pitchX=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->pitchY)-(long)(p)),100,0,0,-1,-1,-1,1,"pitchY=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->positionX)-(long)(p)),100,0,0,-1,-1,-1,1,"positionX=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->positionY)-(long)(p)),100,0,0,-1,-1,-1,1,"positionY=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->positionZ)-(long)(p)),100,0,0,-1,-1,-1,1,"positionZ=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->radLength)-(long)(p)),100,0,0,-1,-1,-1,1,"radLength=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->resolution)-(long)(p)),100,0,0,-1,-1,-1,1,"resolution=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->rotation1)-(long)(p)),100,0,0,-1,-1,-1,1,"rotation1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->rotation2)-(long)(p)),100,0,0,-1,-1,-1,1,"rotation2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->rotation3)-(long)(p)),100,0,0,-1,-1,-1,1,"rotation3=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->rotation4)-(long)(p)),100,0,0,-1,-1,-1,1,"rotation4=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->sizeX)-(long)(p)),100,0,0,-1,-1,-1,1,"sizeX=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->sizeY)-(long)(p)),100,0,0,-1,-1,-1,1,"sizeY=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->thickness)-(long)(p)),100,0,0,-1,-1,-1,1,"thickness=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Xlayer */
static void G__setup_memvarXlayer(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_Xlayer));
   { Xlayer *p; p=(Xlayer*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->ladder)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictOutputLN_Xladder),-1,-1,1,"ladder=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->sensitive)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictOutputLN_Xsensitive),-1,-1,1,"sensitive=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Xdetector */
static void G__setup_memvarXdetector(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_Xdetector));
   { Xdetector *p; p=(Xdetector*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->geartype)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictOutputLN_string),-1,-1,1,"geartype=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->name)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictOutputLN_string),-1,-1,1,"name=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->siplanesID)-(long)(p)),100,0,0,-1,-1,-1,1,"siplanesID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->siplanesType)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictOutputLN_string),-1,-1,1,"siplanesType=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->siplanesNumber)-(long)(p)),100,0,0,-1,-1,-1,1,"siplanesNumber=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->layer)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictOutputLN_vectorlEXlayercOallocatorlEXlayergRsPgR),G__defined_typename("vector<Xlayer>"),-1,1,"layer=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* XBField */
static void G__setup_memvarXBField(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_XBField));
   { XBField *p; p=(XBField*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->type)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictOutputLN_string),-1,-1,1,"type=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->x)-(long)(p)),100,0,0,-1,-1,-1,1,"x=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->y)-(long)(p)),100,0,0,-1,-1,-1,1,"y=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->z)-(long)(p)),100,0,0,-1,-1,-1,1,"z=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* Xgear */
static void G__setup_memvarXgear(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_Xgear));
   { Xgear *p; p=(Xgear*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->detectorName)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictOutputLN_string),-1,-1,1,"detectorName=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->bfield)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictOutputLN_XBField),-1,-1,1,"bfield=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->detector)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictOutputLN_Xdetector),-1,-1,1,"detector=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* S_Cut */
static void G__setup_memvarS_Cut(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_S_Cut));
   { S_Cut *p; p=(S_Cut*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* S_NoCut */
static void G__setup_memvarS_NoCut(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_S_NoCut));
   { S_NoCut *p; p=(S_NoCut*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* S_XCut */
static void G__setup_memvarS_XCut(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_S_XCut));
   { S_XCut *p; p=(S_XCut*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* S_YCut */
static void G__setup_memvarS_YCut(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_S_YCut));
   { S_YCut *p; p=(S_YCut*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* S_Cut_BinContent */
static void G__setup_memvarS_Cut_BinContent(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_S_Cut_BinContent));
   { S_Cut_BinContent *p; p=(S_Cut_BinContent*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* S_CutCoollection */
static void G__setup_memvarS_CutCoollection(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_S_CutCoollection));
   { S_CutCoollection *p; p=(S_CutCoollection*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* MinMaxRange */
static void G__setup_memvarMinMaxRange(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_MinMaxRange));
   { MinMaxRange *p; p=(MinMaxRange*)0x1000; if (p) { }
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"m_min=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"m_max=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"m_stepSize=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* xml_globalConfig */
static void G__setup_memvarxml_globalConfig(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_xml_globalConfig));
   { xml_globalConfig *p; p=(xml_globalConfig*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->CollectionName)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictOutputLN_string),-1,-1,1,"CollectionName=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->NumberOfBins)-(long)(p)),105,0,0,-1,-1,-1,1,"NumberOfBins=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->NumberOfStrips)-(long)(p)),105,0,0,-1,-1,-1,1,"NumberOfStrips=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Device)-(long)(p)),105,0,0,-1,-1,-1,1,"Device=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->AvtiveStrips)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictOutputLN_MinMaxRange),-1,-1,1,"AvtiveStrips=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Rotation)-(long)(p)),100,0,0,-1,-1,-1,1,"Rotation=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Position_name)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictOutputLN_string),-1,-1,1,"Position_name=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Position_value)-(long)(p)),100,0,0,-1,-1,-1,1,"Position_value=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->residual_cut)-(long)(p)),100,0,0,-1,-1,-1,1,"residual_cut=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->gearFile)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictOutputLN_string),-1,-1,1,"gearFile=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* xml_file */
static void G__setup_memvarxml_file(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_xml_file));
   { xml_file *p; p=(xml_file*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->name)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictOutputLN_string),-1,-1,1,"name=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->threshold)-(long)(p)),100,0,0,-1,-1,-1,1,"threshold=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->HV)-(long)(p)),100,0,0,-1,-1,-1,1,"HV=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->runNumber)-(long)(p)),105,0,0,-1,-1,-1,1,"runNumber=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* XML_imput_file */
static void G__setup_memvarXML_imput_file(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_XML_imput_file));
   { XML_imput_file *p; p=(XML_imput_file*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->globalConfig)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__DictOutputLN_xml_globalConfig),-1,-1,1,"globalConfig=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__DictOutputLN_vectorlExml_filecOallocatorlExml_filegRsPgR),G__defined_typename("vector<xml_file>"),-1,4,"m_files=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* DrawOption */
static void G__setup_memvarDrawOption(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__DictOutputLN_DrawOption));
   { DrawOption *p; p=(DrawOption*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarDictOutput() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncProcessorCollection(void) {
   /* ProcessorCollection */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_ProcessorCollection));
   G__memfunc_setup("ProcessorCollection",1996,G__DictOutput_251_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_ProcessorCollection), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("init",436,G__DictOutput_251_0_2, 105, G__get_linked_tagnum(&G__DictOutputLN_init_returns), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__DictOutput_251_0_3, 105, G__get_linked_tagnum(&G__DictOutputLN_end_returns), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("loop",442,G__DictOutput_251_0_4, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("loop",442,G__DictOutput_251_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("next",447,G__DictOutput_251_0_6, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("next_debug",1061,G__DictOutput_251_0_7, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ProcessorCollection", 1996, G__DictOutput_251_0_8, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_ProcessorCollection), -1, 0, 1, 1, 1, 0, "u 'ProcessorCollection' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ProcessorCollection", 2122, G__DictOutput_251_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_251_0_10, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_ProcessorCollection), -1, 1, 1, 1, 1, 0, "u 'ProcessorCollection' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncaxis(void) {
   /* axis */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_axis));
   G__memfunc_setup("axis",437,G__DictOutput_253_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_axis), -1, 0, 1, 1, 1, 0, "u 'axis' - 11 - ax", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__DictOutput_253_0_2, 117, G__get_linked_tagnum(&G__DictOutputLN_axis), -1, 1, 1, 1, 1, 0, "u 'axis' - 11 - ax", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("getValue",829,G__DictOutput_253_0_3, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("next",447,G__DictOutput_253_0_4, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_ProcessorCollection",2411,G__DictOutput_253_0_5, 85, G__get_linked_tagnum(&G__DictOutputLN_ProcessorCollection), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_tree",847,G__DictOutput_253_0_6, 85, G__get_linked_tagnum(&G__DictOutputLN_TTree), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_ID",556,G__DictOutput_253_0_7, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~axis", 563, G__DictOutput_253_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncgeneric_plane(void) {
   /* generic_plane */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_generic_plane));
   G__memfunc_setup("generic_plane",1356,G__DictOutput_254_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_generic_plane), -1, 0, 1, 1, 1, 0, "u 'generic_plane' - 11 - pl", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__DictOutput_254_0_2, 117, G__get_linked_tagnum(&G__DictOutputLN_generic_plane), -1, 1, 1, 1, 1, 0, "u 'generic_plane' - 11 - pl", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("generic_plane",1356,G__DictOutput_254_0_3, 105, G__get_linked_tagnum(&G__DictOutputLN_generic_plane), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("add_axis",829,G__DictOutput_254_0_4, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - axisName U 'vector<double,allocator<double> >' 'vector<double>' 0 - axis_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("setHitAxisAdress",1640,G__DictOutput_254_0_5, 103, -1, -1, 0, 2, 1, 1, 0, 
"u 'string' - 11 - name D - - 0 - outVar", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("next",447,G__DictOutput_254_0_6, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push",448,G__DictOutput_254_0_7, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push",448,G__DictOutput_254_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "d - - 0 - planeID", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_axis",852,G__DictOutput_254_0_9, 117, G__get_linked_tagnum(&G__DictOutputLN_axis), -1, 0, 1, 1, 1, 8, "u 'string' - 11 - axisName", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_ProcessorCollection",2411,G__DictOutput_254_0_10, 85, G__get_linked_tagnum(&G__DictOutputLN_ProcessorCollection), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_tree",847,G__DictOutput_254_0_11, 85, G__get_linked_tagnum(&G__DictOutputLN_TTree), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_ID",556,G__DictOutput_254_0_12, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~generic_plane", 1482, G__DictOutput_254_0_13, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncprocessor_prob(void) {
   /* processor_prob */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_processor_prob));
   G__memfunc_setup("save2Disk",876,G__DictOutput_255_0_1, 117, G__get_linked_tagnum(&G__DictOutputLN_processor_prob), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("dontSave2Disk",1281,G__DictOutput_255_0_2, 117, G__get_linked_tagnum(&G__DictOutputLN_processor_prob), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("setName",717,G__DictOutput_255_0_3, 117, G__get_linked_tagnum(&G__DictOutputLN_processor_prob), -1, 1, 1, 1, 1, 0, "u 'string' - 11 - name", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("addAxis",702,G__DictOutput_255_0_4, 117, G__get_linked_tagnum(&G__DictOutputLN_processor_prob), -1, 1, 1, 1, 1, 0, "u 'string' - 11 - AxisName", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("setAxis",737,G__DictOutput_255_0_5, 117, G__get_linked_tagnum(&G__DictOutputLN_processor_prob), -1, 1, 1, 1, 1, 0, "u 'vector<string,allocator<string> >' 'vector<std::string>' 11 - AxisNames", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("setProcessorCollection",2328,G__DictOutput_255_0_6, 117, G__get_linked_tagnum(&G__DictOutputLN_processor_prob), -1, 1, 1, 1, 1, 0, "U 'ProcessorCollection' - 0 - PC", (char*)NULL, (void*) NULL, 0);
   // automatic default constructor
   G__memfunc_setup("processor_prob", 1522, G__DictOutput_255_0_7, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_processor_prob), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("processor_prob", 1522, G__DictOutput_255_0_8, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_processor_prob), -1, 0, 1, 1, 1, 0, "u 'processor_prob' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~processor_prob", 1648, G__DictOutput_255_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_255_0_10, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_processor_prob), -1, 1, 1, 1, 1, 0, "u 'processor_prob' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfunccollection(void) {
   /* collection */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_collection));
   G__memfunc_setup("collection",1068,G__DictOutput_258_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_collection), -1, 0, 2, 1, 1, 0, 
"U 'TTree' - 0 - tree U 'ProcessorCollection' - 0 - pc", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("collection",1068,G__DictOutput_258_0_2, 105, G__get_linked_tagnum(&G__DictOutputLN_collection), -1, 0, 4, 1, 1, 0, 
"u 'string' - 11 - collectionName u 'vector<string,allocator<string> >' 'vector<std::string>' 11 - axis_list "
"U 'ProcessorCollection' - 0 - pc i 'SaveOption' - 0 'DontSave2Disk' save", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("collection",1068,G__DictOutput_258_0_3, 105, G__get_linked_tagnum(&G__DictOutputLN_collection), -1, 0, 1, 1, 1, 0, "u 'processor_prob' - 11 - pprob", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("collection",1068,G__DictOutput_258_0_4, 105, G__get_linked_tagnum(&G__DictOutputLN_collection), -1, 0, 1, 1, 1, 0, "u 'collection' - 11 - coll", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__DictOutput_258_0_5, 117, G__get_linked_tagnum(&G__DictOutputLN_collection), -1, 1, 1, 1, 1, 0, "u 'collection' - 11 - coll", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("getPlane",816,G__DictOutput_258_0_6, 117, G__get_linked_tagnum(&G__DictOutputLN_generic_plane), -1, 0, 1, 1, 1, 0, "d - - 0 - planeID", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("getAxis",725,G__DictOutput_258_0_7, 117, G__get_linked_tagnum(&G__DictOutputLN_axis), -1, 0, 2, 1, 1, 0, 
"d - - 0 - planeID u 'string' - 11 - axis_name", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("set_Event_Nr",1228,G__DictOutput_258_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "i - - 0 - EventNR", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_Event_Nr",1216,G__DictOutput_258_0_9, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__DictOutput_258_0_10, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("save",431,G__DictOutput_258_0_11, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_name",832,G__DictOutput_258_0_12, 117, G__get_linked_tagnum(&G__DictOutputLN_string), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_ProcessorCollection",2411,G__DictOutput_258_0_13, 85, G__get_linked_tagnum(&G__DictOutputLN_ProcessorCollection), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_tree",847,G__DictOutput_258_0_14, 85, G__get_linked_tagnum(&G__DictOutputLN_TTree), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~collection", 1194, G__DictOutput_258_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncEUTFile(void) {
   /* EUTFile */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_EUTFile));
   G__memfunc_setup("EUTFile",622,G__DictOutput_269_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_EUTFile), -1, 0, 2, 1, 1, 0, 
"U 'TFile' - 0 - inputFile U 'ProcessorCollection' - 0 - pc", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("getCollection",1356,G__DictOutput_269_0_2, 85, G__get_linked_tagnum(&G__DictOutputLN_collection), -1, 0, 1, 1, 1, 0, "C - - 10 - name", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("getProcessorCollection",2316,G__DictOutput_269_0_3, 85, G__get_linked_tagnum(&G__DictOutputLN_ProcessorCollection), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("EUTFile", 622, G__DictOutput_269_0_4, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_EUTFile), -1, 0, 1, 1, 1, 0, "u 'EUTFile' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~EUTFile", 748, G__DictOutput_269_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_269_0_6, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_EUTFile), -1, 1, 1, 1, 1, 0, "u 'EUTFile' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncprocessor(void) {
   /* processor */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_processor));
   G__memfunc_setup("init",436,G__DictOutput_273_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_init_returns), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("processEvent",1281,G__DictOutput_273_0_2, 105, G__get_linked_tagnum(&G__DictOutputLN_process_returns), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("fill",423,G__DictOutput_273_0_3, 105, G__get_linked_tagnum(&G__DictOutputLN_process_returns), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("end",311,G__DictOutput_273_0_4, 105, G__get_linked_tagnum(&G__DictOutputLN_end_returns), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("get_name",832,G__DictOutput_273_0_5, 117, G__get_linked_tagnum(&G__DictOutputLN_string), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("get_lastError",1373,G__DictOutput_273_0_6, 117, G__get_linked_tagnum(&G__DictOutputLN_string), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("addError",819,G__DictOutput_273_0_7, 121, -1, -1, 0, 1, 1, 1, 0, "u 'string' - 11 - error_discription", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resetErrors",1184,G__DictOutput_273_0_8, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~processor", 1118, G__DictOutput_273_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_273_0_10, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_processor), -1, 1, 1, 1, 1, 0, "u 'processor' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfunchit(void) {
   /* hit */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_hit));
   G__memfunc_setup("hit",325,G__DictOutput_274_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_hit), -1, 0, 2, 1, 1, 0, 
"d - - 0 '0' x_ d - - 0 '0' y_", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("hit", 325, G__DictOutput_274_0_2, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_hit), -1, 0, 1, 1, 1, 0, "u 'hit' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~hit", 451, G__DictOutput_274_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_274_0_4, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_hit), -1, 1, 1, 1, 1, 0, "u 'hit' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncfitterHit(void) {
   /* fitterHit */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_fitterHit));
   G__memfunc_setup("fitterHit",947,G__DictOutput_275_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_fitterHit), -1, 0, 6, 1, 1, 0, 
"d - - 0 '0' x_ d - - 0 '0' y_ "
"d - - 0 '0' theta_ d - - 0 '0' phi_ "
"d - - 0 '0' chi2_ d - - 0 '0' ndf_", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("fitterHit", 947, G__DictOutput_275_0_2, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_fitterHit), -1, 0, 1, 1, 1, 0, "u 'fitterHit' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~fitterHit", 1073, G__DictOutput_275_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_275_0_4, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_fitterHit), -1, 1, 1, 1, 1, 0, "u 'fitterHit' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncplane(void) {
   /* plane */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_plane));
   G__memfunc_setup("get_hit",740,G__DictOutput_276_0_3, 85, G__get_linked_tagnum(&G__DictOutputLN_hit), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 3);
   G__memfunc_setup("next",447,G__DictOutput_276_0_4, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_ProcessorCollection",2411,G__DictOutput_276_0_5, 85, G__get_linked_tagnum(&G__DictOutputLN_ProcessorCollection), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_generic_plane",1771,G__DictOutput_276_0_6, 85, G__get_linked_tagnum(&G__DictOutputLN_generic_plane), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_generic_plane",1771,G__DictOutput_276_0_7, 85, G__get_linked_tagnum(&G__DictOutputLN_generic_plane), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~plane", 654, G__DictOutput_276_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_276_0_9, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_plane), -1, 1, 1, 1, 1, 0, "u 'plane' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncxy_plane(void) {
   /* xy_plane */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_xy_plane));
   G__memfunc_setup("xy_plane",864,G__DictOutput_277_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_xy_plane), -1, 0, 1, 1, 1, 0, "u 'generic_plane' - 11 - pl", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("xy_plane",864,G__DictOutput_277_0_2, 105, G__get_linked_tagnum(&G__DictOutputLN_xy_plane), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_hit",740,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__DictOutputLN_hit), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("get_x",535,G__DictOutput_277_0_4, 117, G__get_linked_tagnum(&G__DictOutputLN_axis), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_y",536,G__DictOutput_277_0_5, 117, G__get_linked_tagnum(&G__DictOutputLN_axis), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("xy_plane", 864, G__DictOutput_277_0_6, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_xy_plane), -1, 0, 1, 1, 1, 0, "u 'xy_plane' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~xy_plane", 990, G__DictOutput_277_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_277_0_8, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_xy_plane), -1, 1, 1, 1, 1, 0, "u 'xy_plane' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncFitterPlane(void) {
   /* FitterPlane */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_FitterPlane));
   G__memfunc_setup("FitterPlane",1118,G__DictOutput_278_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_FitterPlane), -1, 0, 1, 1, 1, 0, "u 'generic_plane' - 11 - pl", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("FitterPlane",1118,G__DictOutput_278_0_2, 105, G__get_linked_tagnum(&G__DictOutputLN_FitterPlane), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_hit",740,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__DictOutputLN_hit), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("get_fitterHit",1362,G__DictOutput_278_0_4, 85, G__get_linked_tagnum(&G__DictOutputLN_fitterHit), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("FitterPlane", 1118, G__DictOutput_278_0_5, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_FitterPlane), -1, 0, 1, 1, 1, 0, "u 'FitterPlane' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~FitterPlane", 1244, G__DictOutput_278_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_278_0_7, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_FitterPlane), -1, 1, 1, 1, 1, 0, "u 'FitterPlane' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncprocessorPlaneVSPlane(void) {
   /* processorPlaneVSPlane */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_processorPlaneVSPlane));
   G__memfunc_setup("processorPlaneVSPlane",2153,G__DictOutput_279_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_processorPlaneVSPlane), -1, 0, 3, 1, 1, 0, 
"u 'xy_plane' - 11 - plane_A u 'xy_plane' - 11 - plane_b "
"u 'processor_prob' - 1 - plot_prob", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("init",436,(G__InterfaceMethod) NULL,105, G__get_linked_tagnum(&G__DictOutputLN_init_returns), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("processEvent",1281,(G__InterfaceMethod) NULL,105, G__get_linked_tagnum(&G__DictOutputLN_process_returns), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("fill",423,(G__InterfaceMethod) NULL,105, G__get_linked_tagnum(&G__DictOutputLN_process_returns), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("end",311,(G__InterfaceMethod) NULL,105, G__get_linked_tagnum(&G__DictOutputLN_end_returns), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("get_name",832,(G__InterfaceMethod) NULL,117, G__get_linked_tagnum(&G__DictOutputLN_string), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("processEventStart",1807,G__DictOutput_279_0_7, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("processHit",1060,G__DictOutput_279_0_8, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'hit' - 11 - p1 u 'hit' - 11 - p2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("processHit_1",1204,G__DictOutput_279_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "u 'hit' - 11 - p1", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("processHit_2",1205,G__DictOutput_279_0_10, 121, -1, -1, 0, 1, 1, 1, 0, "u 'hit' - 11 - p2", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("processEventEnd",1560,G__DictOutput_279_0_11, 105, G__get_linked_tagnum(&G__DictOutputLN_process_returns), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("pushHit",741,G__DictOutput_279_0_12, 121, -1, -1, 0, 3, 1, 1, 0, 
"d - - 0 - x d - - 0 - y "
"d - - 0 '0' ID", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pushHit",741,G__DictOutput_279_0_13, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'hit' - 11 - hit d - - 0 - ID", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_output_collection",2267,G__DictOutput_279_0_14, 85, G__get_linked_tagnum(&G__DictOutputLN_collection), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("processorPlaneVSPlane", 2153, G__DictOutput_279_0_15, (int) ('i'), 
G__get_linked_tagnum(&G__DictOutputLN_processorPlaneVSPlane), -1, 0, 1, 1, 1, 0, "u 'processorPlaneVSPlane' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~processorPlaneVSPlane", 2279, G__DictOutput_279_0_16, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_279_0_17, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_processorPlaneVSPlane), -1, 1, 1, 1, 1, 0, "u 'processorPlaneVSPlane' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncXladder(void) {
   /* Xladder */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_Xladder));
   G__memfunc_setup("Xladder",708,G__DictOutput_281_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_Xladder), -1, 0, 1, 1, 1, 0, "U 'rapid_xml_node' - 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Xladder",708,G__DictOutput_281_0_2, 105, G__get_linked_tagnum(&G__DictOutputLN_Xladder), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Xladder", 708, G__DictOutput_281_0_3, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_Xladder), -1, 0, 1, 1, 1, 0, "u 'Xladder' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Xladder", 834, G__DictOutput_281_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_281_0_5, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_Xladder), -1, 1, 1, 1, 1, 0, "u 'Xladder' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncXsensitive(void) {
   /* Xsensitive */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_Xsensitive));
   G__memfunc_setup("Xsensitive",1074,G__DictOutput_282_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_Xsensitive), -1, 0, 1, 1, 1, 0, "U 'rapid_xml_node' - 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Xsensitive",1074,G__DictOutput_282_0_2, 105, G__get_linked_tagnum(&G__DictOutputLN_Xsensitive), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Xsensitive", 1074, G__DictOutput_282_0_3, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_Xsensitive), -1, 0, 1, 1, 1, 0, "u 'Xsensitive' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Xsensitive", 1200, G__DictOutput_282_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_282_0_5, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_Xsensitive), -1, 1, 1, 1, 1, 0, "u 'Xsensitive' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncXlayer(void) {
   /* Xlayer */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_Xlayer));
   G__memfunc_setup("Xlayer",629,G__DictOutput_283_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_Xlayer), -1, 0, 1, 1, 1, 0, "U 'rapid_xml_node' - 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NodeName",775,G__DictOutput_283_0_2, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&Xlayer::NodeName) ), 0);
   // automatic copy constructor
   G__memfunc_setup("Xlayer", 629, G__DictOutput_283_0_3, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_Xlayer), -1, 0, 1, 1, 1, 0, "u 'Xlayer' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Xlayer", 755, G__DictOutput_283_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_283_0_5, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_Xlayer), -1, 1, 1, 1, 1, 0, "u 'Xlayer' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncXdetector(void) {
   /* Xdetector */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_Xdetector));
   G__memfunc_setup("Xdetector",946,G__DictOutput_284_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_Xdetector), -1, 0, 1, 1, 1, 0, "U 'rapid_xml_node' - 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Xdetector",946,G__DictOutput_284_0_2, 105, G__get_linked_tagnum(&G__DictOutputLN_Xdetector), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("layer_by_ID",1091,G__DictOutput_284_0_3, 85, G__get_linked_tagnum(&G__DictOutputLN_Xlayer), -1, 0, 1, 1, 1, 0, "d - - 0 - ID", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("layer_by_ID",1091,G__DictOutput_284_0_4, 85, G__get_linked_tagnum(&G__DictOutputLN_Xlayer), -1, 0, 1, 1, 1, 9, "d - - 0 - ID", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Xdetector", 946, G__DictOutput_284_0_5, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_Xdetector), -1, 0, 1, 1, 1, 0, "u 'Xdetector' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Xdetector", 1072, G__DictOutput_284_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_284_0_7, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_Xdetector), -1, 1, 1, 1, 1, 0, "u 'Xdetector' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncXBField(void) {
   /* XBField */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_XBField));
   G__memfunc_setup("XBField",638,G__DictOutput_294_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_XBField), -1, 0, 1, 1, 1, 0, "U 'rapid_xml_node' - 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("XBField",638,G__DictOutput_294_0_2, 105, G__get_linked_tagnum(&G__DictOutputLN_XBField), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("XBField", 638, G__DictOutput_294_0_3, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_XBField), -1, 0, 1, 1, 1, 0, "u 'XBField' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~XBField", 764, G__DictOutput_294_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_294_0_5, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_XBField), -1, 1, 1, 1, 1, 0, "u 'XBField' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncXgear(void) {
   /* Xgear */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_Xgear));
   G__memfunc_setup("Xgear",503,G__DictOutput_295_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_Xgear), -1, 0, 1, 1, 1, 0, "U 'rapid_xml_node' - 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Xgear",503,G__DictOutput_295_0_2, 105, G__get_linked_tagnum(&G__DictOutputLN_Xgear), -1, 0, 1, 1, 1, 0, "C - - 10 - name", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Xgear",503,G__DictOutput_295_0_3, 105, G__get_linked_tagnum(&G__DictOutputLN_Xgear), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Xgear", 503, G__DictOutput_295_0_4, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_Xgear), -1, 0, 1, 1, 1, 0, "u 'Xgear' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Xgear", 629, G__DictOutput_295_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_295_0_6, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_Xgear), -1, 1, 1, 1, 1, 0, "u 'Xgear' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncS_Cut(void) {
   /* S_Cut */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_S_Cut));
   G__memfunc_setup("isOutOfRange",1206,G__DictOutput_296_0_1, 103, -1, -1, 0, 3, 1, 1, 8, 
"d - - 0 - BinContent d - - 0 - x "
"d - - 0 - y", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("isOutOfRange",1206,G__DictOutput_296_0_2, 103, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - BinContent d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("isOutOfRange",1206,G__DictOutput_296_0_3, 103, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - BinContent", (char*)NULL, (void*) NULL, 1);
   // automatic default constructor
   G__memfunc_setup("S_Cut", 478, G__DictOutput_296_0_4, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_S_Cut), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("S_Cut", 478, G__DictOutput_296_0_5, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_S_Cut), -1, 0, 1, 1, 1, 0, "u 'S_Cut' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~S_Cut", 604, G__DictOutput_296_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_296_0_7, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_S_Cut), -1, 1, 1, 1, 1, 0, "u 'S_Cut' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncS_NoCut(void) {
   /* S_NoCut */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_S_NoCut));
   // automatic default constructor
   G__memfunc_setup("S_NoCut", 667, G__DictOutput_297_0_1, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_S_NoCut), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("S_NoCut", 667, G__DictOutput_297_0_2, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_S_NoCut), -1, 0, 1, 1, 1, 0, "u 'S_NoCut' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~S_NoCut", 793, G__DictOutput_297_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_297_0_4, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_S_NoCut), -1, 1, 1, 1, 1, 0, "u 'S_NoCut' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncS_XCut(void) {
   /* S_XCut */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_S_XCut));
   G__memfunc_setup("S_XCut",566,G__DictOutput_299_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_S_XCut), -1, 0, 2, 1, 1, 0, 
"d - - 0 - min_ d - - 0 - max_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("S_XCut",566,G__DictOutput_299_0_2, 105, G__get_linked_tagnum(&G__DictOutputLN_S_XCut), -1, 0, 1, 1, 1, 0, "d - - 0 - min_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("isOutOfRange",1206,(G__InterfaceMethod) NULL,103, -1, -1, 0, 3, 1, 1, 8, 
"d - - 0 - BinContent d - - 0 - x "
"d - - 0 - y", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("isOutOfRange",1206,(G__InterfaceMethod) NULL,103, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - BinContent d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("isOutOfRange",1206,(G__InterfaceMethod) NULL,103, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - BinContent", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("S_XCut", 566, G__DictOutput_299_0_6, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_S_XCut), -1, 0, 1, 1, 1, 0, "u 'S_XCut' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~S_XCut", 692, G__DictOutput_299_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_299_0_8, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_S_XCut), -1, 1, 1, 1, 1, 0, "u 'S_XCut' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncS_YCut(void) {
   /* S_YCut */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_S_YCut));
   G__memfunc_setup("S_YCut",567,G__DictOutput_300_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_S_YCut), -1, 0, 2, 1, 1, 0, 
"d - - 0 - min_ d - - 0 - max_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("S_YCut",567,G__DictOutput_300_0_2, 105, G__get_linked_tagnum(&G__DictOutputLN_S_YCut), -1, 0, 1, 1, 1, 0, "d - - 0 - min_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("isOutOfRange",1206,(G__InterfaceMethod) NULL,103, -1, -1, 0, 3, 1, 1, 8, 
"d - - 0 - BinContent d - - 0 - x "
"d - - 0 - y", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("isOutOfRange",1206,(G__InterfaceMethod) NULL,103, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - BinContent d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("isOutOfRange",1206,(G__InterfaceMethod) NULL,103, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - BinContent", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("S_YCut", 567, G__DictOutput_300_0_6, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_S_YCut), -1, 0, 1, 1, 1, 0, "u 'S_YCut' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~S_YCut", 693, G__DictOutput_300_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_300_0_8, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_S_YCut), -1, 1, 1, 1, 1, 0, "u 'S_YCut' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncS_Cut_BinContent(void) {
   /* S_Cut_BinContent */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_S_Cut_BinContent));
   G__memfunc_setup("S_Cut_BinContent",1585,G__DictOutput_301_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_S_Cut_BinContent), -1, 0, 2, 1, 1, 0, 
"d - - 0 - min_ d - - 0 - max_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("S_Cut_BinContent",1585,G__DictOutput_301_0_2, 105, G__get_linked_tagnum(&G__DictOutputLN_S_Cut_BinContent), -1, 0, 1, 1, 1, 0, "d - - 0 - min_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("isOutOfRange",1206,(G__InterfaceMethod) NULL,103, -1, -1, 0, 3, 1, 1, 8, 
"d - - 0 - BinContent d - - 0 - x "
"d - - 0 - y", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("isOutOfRange",1206,(G__InterfaceMethod) NULL,103, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - BinContent d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("isOutOfRange",1206,(G__InterfaceMethod) NULL,103, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - BinContent", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("S_Cut_BinContent", 1585, G__DictOutput_301_0_6, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_S_Cut_BinContent), -1, 0, 1, 1, 1, 0, "u 'S_Cut_BinContent' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~S_Cut_BinContent", 1711, G__DictOutput_301_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_301_0_8, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_S_Cut_BinContent), -1, 1, 1, 1, 1, 0, "u 'S_Cut_BinContent' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncS_CutCoollection(void) {
   /* S_CutCoollection */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_S_CutCoollection));
   G__memfunc_setup("S_CutCoollection",1625,G__DictOutput_302_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_S_CutCoollection), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("isOutOfRange",1206,(G__InterfaceMethod) NULL,103, -1, -1, 0, 3, 1, 1, 8, 
"d - - 0 - BinContent d - - 0 - x "
"d - - 0 - y", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("isOutOfRange",1206,(G__InterfaceMethod) NULL,103, -1, -1, 0, 2, 1, 1, 8, 
"d - - 0 - BinContent d - - 0 - x", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("isOutOfRange",1206,(G__InterfaceMethod) NULL,103, -1, -1, 0, 1, 1, 1, 8, "d - - 0 - BinContent", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("add_Cut",692,G__DictOutput_302_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "u 'S_Cut' - 11 - cut_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("add_Cut",692,G__DictOutput_302_0_6, 121, -1, -1, 0, 1, 1, 1, 0, "u 'S_CutCoollection' - 11 - cut_", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("S_CutCoollection", 1625, G__DictOutput_302_0_7, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_S_CutCoollection), -1, 0, 1, 1, 1, 0, "u 'S_CutCoollection' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~S_CutCoollection", 1751, G__DictOutput_302_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_302_0_9, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_S_CutCoollection), -1, 1, 1, 1, 1, 0, "u 'S_CutCoollection' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncMinMaxRange(void) {
   /* MinMaxRange */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_MinMaxRange));
   G__memfunc_setup("MinMaxRange",1079,G__DictOutput_303_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_MinMaxRange), -1, 0, 2, 1, 1, 0, 
"i - - 0 - min_ i - - 0 - max_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MinMaxRange",1079,G__DictOutput_303_0_2, 105, G__get_linked_tagnum(&G__DictOutputLN_MinMaxRange), -1, 0, 3, 1, 1, 0, 
"i - - 0 - min_ i - - 0 - step_ "
"i - - 0 - max_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("MinMaxRange",1079,G__DictOutput_303_0_3, 105, G__get_linked_tagnum(&G__DictOutputLN_MinMaxRange), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("getMin",612,G__DictOutput_303_0_4, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("getMax",614,G__DictOutput_303_0_5, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("getStep",732,G__DictOutput_303_0_6, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("MinMaxRange", 1079, G__DictOutput_303_0_7, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_MinMaxRange), -1, 0, 1, 1, 1, 0, "u 'MinMaxRange' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~MinMaxRange", 1205, G__DictOutput_303_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_303_0_9, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_MinMaxRange), -1, 1, 1, 1, 1, 0, "u 'MinMaxRange' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncxml_globalConfig(void) {
   /* xml_globalConfig */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_xml_globalConfig));
   G__memfunc_setup("xml_globalConfig",1655,G__DictOutput_304_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_xml_globalConfig), -1, 0, 1, 1, 1, 0, "U 'rapid_xml_node' - 0 - xIn", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("xml_globalConfig",1655,G__DictOutput_304_0_2, 105, G__get_linked_tagnum(&G__DictOutputLN_xml_globalConfig), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("cut",332,G__DictOutput_304_0_3, 117, G__get_linked_tagnum(&G__DictOutputLN_S_Cut), -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("xml_globalConfig", 1655, G__DictOutput_304_0_4, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_xml_globalConfig), -1, 0, 1, 1, 1, 0, "u 'xml_globalConfig' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~xml_globalConfig", 1781, G__DictOutput_304_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_304_0_6, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_xml_globalConfig), -1, 1, 1, 1, 1, 0, "u 'xml_globalConfig' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncxml_file(void) {
   /* xml_file */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_xml_file));
   G__memfunc_setup("xml_file",848,G__DictOutput_305_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_xml_file), -1, 0, 1, 1, 1, 0, "U 'rapid_xml_node' - 0 - xIn", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("NodeName",775,G__DictOutput_305_0_2, 67, -1, -1, 0, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const char* (*)())(&xml_file::NodeName) ), 0);
   G__memfunc_setup("xml_file",848,G__DictOutput_305_0_3, 105, G__get_linked_tagnum(&G__DictOutputLN_xml_file), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("xml_file", 848, G__DictOutput_305_0_4, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_xml_file), -1, 0, 1, 1, 1, 0, "u 'xml_file' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~xml_file", 974, G__DictOutput_305_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_305_0_6, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_xml_file), -1, 1, 1, 1, 1, 0, "u 'xml_file' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncXML_imput_file(void) {
   /* XML_imput_file */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_XML_imput_file));
   G__memfunc_setup("XML_imput_file",1406,G__DictOutput_306_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_XML_imput_file), -1, 0, 1, 1, 1, 0, "C - - 10 - name", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_File",799,G__DictOutput_306_0_2, 117, G__get_linked_tagnum(&G__DictOutputLN_xml_file), -1, 1, 1, 1, 1, 0, "i - - 0 - id", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_File",799,G__DictOutput_306_0_3, 117, G__get_linked_tagnum(&G__DictOutputLN_xml_file), -1, 1, 1, 1, 1, 9, "i - - 0 - id", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__DictOutput_306_0_4, 105, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("XML_imput_file", 1406, G__DictOutput_306_0_5, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_XML_imput_file), -1, 0, 1, 1, 1, 0, "u 'XML_imput_file' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~XML_imput_file", 1532, G__DictOutput_306_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_306_0_7, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_XML_imput_file), -1, 1, 1, 1, 1, 0, "u 'XML_imput_file' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncDrawOption(void) {
   /* DrawOption */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__DictOutputLN_DrawOption));
   G__memfunc_setup("DrawOption",1031,G__DictOutput_332_0_1, 105, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 0, 3, 1, 1, 0, 
"C - - 10 - options C - - 10 '\"\"' cuts "
"C - - 10 '\"y:x\"' axis", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DrawOption",1031,G__DictOutput_332_0_2, 105, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 0, 3, 1, 1, 0, 
"C - - 10 - options u 'TCut' - 0 - cuts "
"C - - 10 '\"y:x\"' axis", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("DrawOption",1031,G__DictOutput_332_0_3, 105, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("options",780,G__DictOutput_332_0_4, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 1, 1, 1, 0, "C - - 10 - option", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("opt_colz",874,G__DictOutput_332_0_5, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("opt_star",876,G__DictOutput_332_0_6, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("opt_bar",743,G__DictOutput_332_0_7, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("opt_same",856,G__DictOutput_332_0_8, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("opt_color",977,G__DictOutput_332_0_9, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 1, 1, 1, 0, "s - 'Color_t' 0 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("color_red",953,G__DictOutput_332_0_10, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("color_white",1183,G__DictOutput_332_0_11, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("color_black",1147,G__DictOutput_332_0_12, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("color_gray",1073,G__DictOutput_332_0_13, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("color_green",1167,G__DictOutput_332_0_14, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("color_blue",1062,G__DictOutput_332_0_15, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("color_yellow",1306,G__DictOutput_332_0_16, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("color_magenta",1371,G__DictOutput_332_0_17, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("color_cyan",1065,G__DictOutput_332_0_18, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("color_orange",1274,G__DictOutput_332_0_19, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("color_spring",1297,G__DictOutput_332_0_20, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("color_teal",1060,G__DictOutput_332_0_21, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("color_azure",1189,G__DictOutput_332_0_22, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("color_violet",1297,G__DictOutput_332_0_23, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("color_pink",1072,G__DictOutput_332_0_24, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("cut",332,G__DictOutput_332_0_25, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 1, 1, 1, 0, "u 'string' - 11 - cut_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("cut_min",751,G__DictOutput_332_0_26, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 2, 1, 1, 0, 
"u 'string' - 11 - ax d - 'Double_t' 0 - min_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("cut_max",753,G__DictOutput_332_0_27, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 2, 1, 1, 0, 
"u 'string' - 11 - ax d - 'Double_t' 0 - max_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("cut",332,G__DictOutput_332_0_28, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 3, 1, 1, 0, 
"u 'string' - 11 - ax d - 'Double_t' 0 - min_ "
"d - 'Double_t' 0 - max_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("cut_add",724,G__DictOutput_332_0_29, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 1, 1, 1, 0, "u 'TCut' - 11 - cut_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("cut_x",547,G__DictOutput_332_0_30, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 2, 1, 1, 0, 
"d - 'Double_t' 0 - min_ d - 'Double_t' 0 - max_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("cut_x_min",966,G__DictOutput_332_0_31, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 1, 1, 1, 0, "d - 'Double_t' 0 - min_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("cut_x_max",968,G__DictOutput_332_0_32, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 1, 1, 1, 0, "d - 'Double_t' 0 - max_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("cut_y",548,G__DictOutput_332_0_33, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 2, 1, 1, 0, 
"d - 'Double_t' 0 - min_ d - 'Double_t' 0 - max_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("cut_y_min",967,G__DictOutput_332_0_34, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 1, 1, 1, 0, "d - 'Double_t' 0 - min_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("cut_y_max",969,G__DictOutput_332_0_35, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 1, 1, 1, 0, "d - 'Double_t' 0 - max_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("draw_axis",962,G__DictOutput_332_0_36, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 1, 1, 1, 0, "u 'string' - 11 - axis_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("draw_axis",962,G__DictOutput_332_0_37, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 2, 1, 1, 0, 
"u 'string' - 11 - x u 'string' - 11 - y", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("draw_axis",962,G__DictOutput_332_0_38, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 3, 1, 1, 0, 
"u 'string' - 11 - x u 'string' - 11 - y "
"u 'string' - 11 - z", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("draw_x",645,G__DictOutput_332_0_39, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("draw_y",646,G__DictOutput_332_0_40, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("draw_x_VS_y",1125,G__DictOutput_332_0_41, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("draw_y_VS_x",1125,G__DictOutput_332_0_42, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("output_object",1415,G__DictOutput_332_0_43, 117, G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 1, 1, 1, 0, "U 'TObject' - 0 - out_", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("get_output_object",1830,G__DictOutput_332_0_44, 85, G__get_linked_tagnum(&G__DictOutputLN_TObject), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Draw",398,G__DictOutput_332_0_45, 110, -1, G__defined_typename("Long64_t"), 0, 1, 1, 1, 8, "U 'TTree' - 0 - tree", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("getOptions",1068,G__DictOutput_332_0_46, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("getAxis",725,G__DictOutput_332_0_47, 67, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("getCut",620,G__DictOutput_332_0_48, 117, G__get_linked_tagnum(&G__DictOutputLN_TCut), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("DrawOption", 1031, G__DictOutput_332_0_49, (int) ('i'), G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 0, 1, 1, 1, 0, "u 'DrawOption' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~DrawOption", 1157, G__DictOutput_332_0_50, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__DictOutput_332_0_51, (int) ('u'), G__get_linked_tagnum(&G__DictOutputLN_DrawOption), -1, 1, 1, 1, 1, 0, "u 'DrawOption' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncDictOutput() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__DictOutputLN_SaveOption),-1,-1,1,"save2Disk=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__DictOutputLN_SaveOption),-1,-1,1,"DontSave2Disk=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__DictOutputLN_init_returns),-1,-1,1,"i_sucess=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__DictOutputLN_init_returns),-1,-1,1,"i_error=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__DictOutputLN_process_returns),-1,-1,1,"p_sucess=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__DictOutputLN_process_returns),-1,-1,1,"p_skip=1",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__DictOutputLN_process_returns),-1,-1,1,"p_stop=2",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__DictOutputLN_process_returns),-1,-1,1,"p_error=3",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__DictOutputLN_process_returns),-1,-1,1,"p_warning=4",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__DictOutputLN_process_returns),-1,-1,1,"p_dont_save_event=5",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__DictOutputLN_end_returns),-1,-1,1,"e_success=0",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__DictOutputLN_end_returns),-1,-1,1,"e_error=1",0,(char*)NULL);

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalDictOutput() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
   G__memfunc_setup("load_gear", 926, G__DictOutput__0_439, 117, G__get_linked_tagnum(&G__DictOutputLN_Xgear), -1, 0, 1, 1, 1, 0, "C - - 10 - name", (char*) NULL
, (void*) NULL, 0);
}

static void G__cpp_setup_func5() {
   G__memfunc_setup("Draw", 398, G__DictOutput__0_523, 105, -1, -1, 0, 2, 1, 1, 0, 
"u 'axis' - 11 - ax u 'DrawOption' - 0 'DrawOption()' drawOp", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("Draw", 398, G__DictOutput__0_524, 105, -1, -1, 0, 2, 1, 1, 0, 
"u 'generic_plane' - 1 - gp u 'DrawOption' - 0 'DrawOption()' drawOp", (char*) NULL
, (void*) NULL, 0);
   G__memfunc_setup("Draw", 398, G__DictOutput__0_525, 105, -1, -1, 0, 2, 1, 1, 0, 
"u 'xy_plane' - 1 - gp u 'DrawOption' - 0 'DrawOption()' drawOp", (char*) NULL
, (void*) NULL, 0);

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcDictOutput() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__DictOutputLN_TObject = { "TObject" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_iteratorlErandom_access_iterator_tagcOcharcOlongcOcharmUcOcharaNgR = { "iterator<random_access_iterator_tag,char,long,char*,char&>" , 115 , -1 };
G__linked_taginfo G__DictOutputLN_vectorlEdoublecOallocatorlEdoublegRsPgR = { "vector<double,allocator<double> >" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_string = { "string" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_iteratorlErandom_access_iterator_tagcOROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR = { "iterator<random_access_iterator_tag,ROOT::TSchemaHelper,long,ROOT::TSchemaHelper*,ROOT::TSchemaHelper&>" , 115 , -1 };
G__linked_taginfo G__DictOutputLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLconst_iteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::const_iterator>" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR = { "vector<TVirtualArray*,allocator<TVirtualArray*> >" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_iteratorlErandom_access_iterator_tagcOTVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR = { "iterator<random_access_iterator_tag,TVirtualArray*,long,TVirtualArray**,TVirtualArray*&>" , 115 , -1 };
G__linked_taginfo G__DictOutputLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLconst_iteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::const_iterator>" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_ProcessorCollection = { "ProcessorCollection" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_TTree = { "TTree" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_axis = { "axis" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_generic_plane = { "generic_plane" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_processor_prob = { "processor_prob" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_SaveOption = { "SaveOption" , 101 , -1 };
G__linked_taginfo G__DictOutputLN_collection = { "collection" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_vectorlEstringcOallocatorlEstringgRsPgR = { "vector<string,allocator<string> >" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<string,allocator<string> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_iteratorlErandom_access_iterator_tagcOstringcOlongcOstringmUcOstringaNgR = { "iterator<random_access_iterator_tag,string,long,string*,string&>" , 115 , -1 };
G__linked_taginfo G__DictOutputLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLconst_iteratorgR = { "reverse_iterator<vector<string,allocator<string> >::const_iterator>" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_TFile = { "TFile" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_EUTFile = { "EUTFile" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_init_returns = { "init_returns" , 101 , -1 };
G__linked_taginfo G__DictOutputLN_process_returns = { "process_returns" , 101 , -1 };
G__linked_taginfo G__DictOutputLN_end_returns = { "end_returns" , 101 , -1 };
G__linked_taginfo G__DictOutputLN_processor = { "processor" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_hit = { "hit" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_fitterHit = { "fitterHit" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_plane = { "plane" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_xy_plane = { "xy_plane" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_FitterPlane = { "FitterPlane" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_processorPlaneVSPlane = { "processorPlaneVSPlane" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_rapid_xml_node = { "rapid_xml_node" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_Xladder = { "Xladder" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_Xsensitive = { "Xsensitive" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_Xlayer = { "Xlayer" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_Xdetector = { "Xdetector" , 115 , -1 };
G__linked_taginfo G__DictOutputLN_vectorlEXlayercOallocatorlEXlayergRsPgR = { "vector<Xlayer,allocator<Xlayer> >" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_reverse_iteratorlEvectorlEXlayercOallocatorlEXlayergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<Xlayer,allocator<Xlayer> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_iteratorlErandom_access_iterator_tagcOXlayercOlongcOXlayermUcOXlayeraNgR = { "iterator<random_access_iterator_tag,Xlayer,long,Xlayer*,Xlayer&>" , 115 , -1 };
G__linked_taginfo G__DictOutputLN_reverse_iteratorlEvectorlEXlayercOallocatorlEXlayergRsPgRcLcLconst_iteratorgR = { "reverse_iterator<vector<Xlayer,allocator<Xlayer> >::const_iterator>" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_XBField = { "XBField" , 115 , -1 };
G__linked_taginfo G__DictOutputLN_Xgear = { "Xgear" , 115 , -1 };
G__linked_taginfo G__DictOutputLN_S_Cut = { "S_Cut" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_S_NoCut = { "S_NoCut" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_S_Cut_min_max = { "S_Cut_min_max" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_S_XCut = { "S_XCut" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_S_YCut = { "S_YCut" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_S_Cut_BinContent = { "S_Cut_BinContent" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_S_CutCoollection = { "S_CutCoollection" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_MinMaxRange = { "MinMaxRange" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_xml_globalConfig = { "xml_globalConfig" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_xml_file = { "xml_file" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_XML_imput_file = { "XML_imput_file" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_vectorlExml_filecOallocatorlExml_filegRsPgR = { "vector<xml_file,allocator<xml_file> >" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_reverse_iteratorlEvectorlExml_filecOallocatorlExml_filegRsPgRcLcLiteratorgR = { "reverse_iterator<vector<xml_file,allocator<xml_file> >::iterator>" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_iteratorlErandom_access_iterator_tagcOxml_filecOlongcOxml_filemUcOxml_fileaNgR = { "iterator<random_access_iterator_tag,xml_file,long,xml_file*,xml_file&>" , 115 , -1 };
G__linked_taginfo G__DictOutputLN_reverse_iteratorlEvectorlExml_filecOallocatorlExml_filegRsPgRcLcLconst_iteratorgR = { "reverse_iterator<vector<xml_file,allocator<xml_file> >::const_iterator>" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_TCut = { "TCut" , 99 , -1 };
G__linked_taginfo G__DictOutputLN_DrawOption = { "DrawOption" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableDictOutput() {
  G__DictOutputLN_TObject.tagnum = -1 ;
  G__DictOutputLN_iteratorlErandom_access_iterator_tagcOcharcOlongcOcharmUcOcharaNgR.tagnum = -1 ;
  G__DictOutputLN_vectorlEdoublecOallocatorlEdoublegRsPgR.tagnum = -1 ;
  G__DictOutputLN_string.tagnum = -1 ;
  G__DictOutputLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__DictOutputLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictOutputLN_iteratorlErandom_access_iterator_tagcOROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR.tagnum = -1 ;
  G__DictOutputLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLconst_iteratorgR.tagnum = -1 ;
  G__DictOutputLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR.tagnum = -1 ;
  G__DictOutputLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictOutputLN_iteratorlErandom_access_iterator_tagcOTVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR.tagnum = -1 ;
  G__DictOutputLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLconst_iteratorgR.tagnum = -1 ;
  G__DictOutputLN_ProcessorCollection.tagnum = -1 ;
  G__DictOutputLN_TTree.tagnum = -1 ;
  G__DictOutputLN_axis.tagnum = -1 ;
  G__DictOutputLN_generic_plane.tagnum = -1 ;
  G__DictOutputLN_processor_prob.tagnum = -1 ;
  G__DictOutputLN_SaveOption.tagnum = -1 ;
  G__DictOutputLN_collection.tagnum = -1 ;
  G__DictOutputLN_vectorlEstringcOallocatorlEstringgRsPgR.tagnum = -1 ;
  G__DictOutputLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictOutputLN_iteratorlErandom_access_iterator_tagcOstringcOlongcOstringmUcOstringaNgR.tagnum = -1 ;
  G__DictOutputLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLconst_iteratorgR.tagnum = -1 ;
  G__DictOutputLN_TFile.tagnum = -1 ;
  G__DictOutputLN_EUTFile.tagnum = -1 ;
  G__DictOutputLN_init_returns.tagnum = -1 ;
  G__DictOutputLN_process_returns.tagnum = -1 ;
  G__DictOutputLN_end_returns.tagnum = -1 ;
  G__DictOutputLN_processor.tagnum = -1 ;
  G__DictOutputLN_hit.tagnum = -1 ;
  G__DictOutputLN_fitterHit.tagnum = -1 ;
  G__DictOutputLN_plane.tagnum = -1 ;
  G__DictOutputLN_xy_plane.tagnum = -1 ;
  G__DictOutputLN_FitterPlane.tagnum = -1 ;
  G__DictOutputLN_processorPlaneVSPlane.tagnum = -1 ;
  G__DictOutputLN_rapid_xml_node.tagnum = -1 ;
  G__DictOutputLN_Xladder.tagnum = -1 ;
  G__DictOutputLN_Xsensitive.tagnum = -1 ;
  G__DictOutputLN_Xlayer.tagnum = -1 ;
  G__DictOutputLN_Xdetector.tagnum = -1 ;
  G__DictOutputLN_vectorlEXlayercOallocatorlEXlayergRsPgR.tagnum = -1 ;
  G__DictOutputLN_reverse_iteratorlEvectorlEXlayercOallocatorlEXlayergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictOutputLN_iteratorlErandom_access_iterator_tagcOXlayercOlongcOXlayermUcOXlayeraNgR.tagnum = -1 ;
  G__DictOutputLN_reverse_iteratorlEvectorlEXlayercOallocatorlEXlayergRsPgRcLcLconst_iteratorgR.tagnum = -1 ;
  G__DictOutputLN_XBField.tagnum = -1 ;
  G__DictOutputLN_Xgear.tagnum = -1 ;
  G__DictOutputLN_S_Cut.tagnum = -1 ;
  G__DictOutputLN_S_NoCut.tagnum = -1 ;
  G__DictOutputLN_S_Cut_min_max.tagnum = -1 ;
  G__DictOutputLN_S_XCut.tagnum = -1 ;
  G__DictOutputLN_S_YCut.tagnum = -1 ;
  G__DictOutputLN_S_Cut_BinContent.tagnum = -1 ;
  G__DictOutputLN_S_CutCoollection.tagnum = -1 ;
  G__DictOutputLN_MinMaxRange.tagnum = -1 ;
  G__DictOutputLN_xml_globalConfig.tagnum = -1 ;
  G__DictOutputLN_xml_file.tagnum = -1 ;
  G__DictOutputLN_XML_imput_file.tagnum = -1 ;
  G__DictOutputLN_vectorlExml_filecOallocatorlExml_filegRsPgR.tagnum = -1 ;
  G__DictOutputLN_reverse_iteratorlEvectorlExml_filecOallocatorlExml_filegRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__DictOutputLN_iteratorlErandom_access_iterator_tagcOxml_filecOlongcOxml_filemUcOxml_fileaNgR.tagnum = -1 ;
  G__DictOutputLN_reverse_iteratorlEvectorlExml_filecOallocatorlExml_filegRsPgRcLcLconst_iteratorgR.tagnum = -1 ;
  G__DictOutputLN_TCut.tagnum = -1 ;
  G__DictOutputLN_DrawOption.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableDictOutput() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__DictOutputLN_TObject);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOcharcOlongcOcharmUcOcharaNgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_vectorlEdoublecOallocatorlEdoublegRsPgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_string);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOROOTcLcLTSchemaHelpercOlongcOROOTcLcLTSchemaHelpermUcOROOTcLcLTSchemaHelperaNgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLconst_iteratorgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOTVirtualArraymUcOlongcOTVirtualArraymUmUcOTVirtualArraymUaNgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLconst_iteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_ProcessorCollection),sizeof(ProcessorCollection),-1,256,(char*)NULL,G__setup_memvarProcessorCollection,G__setup_memfuncProcessorCollection);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_TTree);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_axis),sizeof(axis),-1,2560,(char*)NULL,G__setup_memvaraxis,G__setup_memfuncaxis);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_generic_plane),sizeof(generic_plane),-1,2816,(char*)NULL,G__setup_memvargeneric_plane,G__setup_memfuncgeneric_plane);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_processor_prob),sizeof(processor_prob),-1,0,(char*)NULL,G__setup_memvarprocessor_prob,G__setup_memfuncprocessor_prob);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_SaveOption),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_collection),sizeof(collection),-1,35328,(char*)NULL,G__setup_memvarcollection,G__setup_memfunccollection);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_vectorlEstringcOallocatorlEstringgRsPgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOstringcOlongcOstringmUcOstringaNgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_reverse_iteratorlEvectorlEstringcOallocatorlEstringgRsPgRcLcLconst_iteratorgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_TFile);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_EUTFile),sizeof(EUTFile),-1,32768,(char*)NULL,G__setup_memvarEUTFile,G__setup_memfuncEUTFile);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_init_returns),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_process_returns),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_end_returns),sizeof(int),-1,0,(char*)NULL,NULL,NULL);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_processor),sizeof(processor),-1,5,(char*)NULL,G__setup_memvarprocessor,G__setup_memfuncprocessor);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_hit),sizeof(hit),-1,256,(char*)NULL,G__setup_memvarhit,G__setup_memfunchit);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_fitterHit),sizeof(fitterHit),-1,256,(char*)NULL,G__setup_memvarfitterHit,G__setup_memfuncfitterHit);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_plane),sizeof(plane),-1,33025,(char*)NULL,G__setup_memvarplane,G__setup_memfuncplane);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_xy_plane),sizeof(xy_plane),-1,33024,(char*)NULL,G__setup_memvarxy_plane,G__setup_memfuncxy_plane);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_FitterPlane),sizeof(FitterPlane),-1,33024,(char*)NULL,G__setup_memvarFitterPlane,G__setup_memfuncFitterPlane);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_processorPlaneVSPlane),sizeof(processorPlaneVSPlane),-1,32768,(char*)NULL,G__setup_memvarprocessorPlaneVSPlane,G__setup_memfuncprocessorPlaneVSPlane);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_rapid_xml_node);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_Xladder),sizeof(Xladder),-1,33024,(char*)NULL,G__setup_memvarXladder,G__setup_memfuncXladder);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_Xsensitive),sizeof(Xsensitive),-1,33024,(char*)NULL,G__setup_memvarXsensitive,G__setup_memfuncXsensitive);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_Xlayer),sizeof(Xlayer),-1,32768,(char*)NULL,G__setup_memvarXlayer,G__setup_memfuncXlayer);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_Xdetector),sizeof(Xdetector),-1,33024,(char*)NULL,G__setup_memvarXdetector,G__setup_memfuncXdetector);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_vectorlEXlayercOallocatorlEXlayergRsPgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_reverse_iteratorlEvectorlEXlayercOallocatorlEXlayergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOXlayercOlongcOXlayermUcOXlayeraNgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_reverse_iteratorlEvectorlEXlayercOallocatorlEXlayergRsPgRcLcLconst_iteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_XBField),sizeof(XBField),-1,33024,(char*)NULL,G__setup_memvarXBField,G__setup_memfuncXBField);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_Xgear),sizeof(Xgear),-1,33024,(char*)NULL,G__setup_memvarXgear,G__setup_memfuncXgear);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_S_Cut),sizeof(S_Cut),-1,1024,(char*)NULL,G__setup_memvarS_Cut,G__setup_memfuncS_Cut);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_S_NoCut),sizeof(S_NoCut),-1,1024,(char*)NULL,G__setup_memvarS_NoCut,G__setup_memfuncS_NoCut);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_S_Cut_min_max);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_S_XCut),sizeof(S_XCut),-1,32768,(char*)NULL,G__setup_memvarS_XCut,G__setup_memfuncS_XCut);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_S_YCut),sizeof(S_YCut),-1,32768,(char*)NULL,G__setup_memvarS_YCut,G__setup_memfuncS_YCut);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_S_Cut_BinContent),sizeof(S_Cut_BinContent),-1,32768,(char*)NULL,G__setup_memvarS_Cut_BinContent,G__setup_memfuncS_Cut_BinContent);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_S_CutCoollection),sizeof(S_CutCoollection),-1,256,(char*)NULL,G__setup_memvarS_CutCoollection,G__setup_memfuncS_CutCoollection);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_MinMaxRange),sizeof(MinMaxRange),-1,33024,(char*)NULL,G__setup_memvarMinMaxRange,G__setup_memfuncMinMaxRange);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_xml_globalConfig),sizeof(xml_globalConfig),-1,33024,(char*)NULL,G__setup_memvarxml_globalConfig,G__setup_memfuncxml_globalConfig);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_xml_file),sizeof(xml_file),-1,33024,(char*)NULL,G__setup_memvarxml_file,G__setup_memfuncxml_file);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_XML_imput_file),sizeof(XML_imput_file),-1,32768,(char*)NULL,G__setup_memvarXML_imput_file,G__setup_memfuncXML_imput_file);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_vectorlExml_filecOallocatorlExml_filegRsPgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_reverse_iteratorlEvectorlExml_filecOallocatorlExml_filegRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_iteratorlErandom_access_iterator_tagcOxml_filecOlongcOxml_filemUcOxml_fileaNgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_reverse_iteratorlEvectorlExml_filecOallocatorlExml_filegRsPgRcLcLconst_iteratorgR);
   G__get_linked_tagnum_fwd(&G__DictOutputLN_TCut);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__DictOutputLN_DrawOption),sizeof(DrawOption),-1,33024,(char*)NULL,G__setup_memvarDrawOption,G__setup_memfuncDrawOption);
}
extern "C" void G__cpp_setupDictOutput(void) {
  G__check_setup_version(30051515,"G__cpp_setupDictOutput()");
  G__set_cpp_environmentDictOutput();
  G__cpp_setup_tagtableDictOutput();

  G__cpp_setup_inheritanceDictOutput();

  G__cpp_setup_typetableDictOutput();

  G__cpp_setup_memvarDictOutput();

  G__cpp_setup_memfuncDictOutput();
  G__cpp_setup_globalDictOutput();
  G__cpp_setup_funcDictOutput();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncDictOutput();
  return;
}
class G__cpp_setup_initDictOutput {
  public:
    G__cpp_setup_initDictOutput() { G__add_setup_func("DictOutput",(G__incsetup)(&G__cpp_setupDictOutput)); G__call_setup_funcs(); }
   ~G__cpp_setup_initDictOutput() { G__remove_setup_func("DictOutput"); }
};
G__cpp_setup_initDictOutput G__cpp_setup_initializerDictOutput;

